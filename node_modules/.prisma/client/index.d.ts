
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  username: string
  email: string
  password: string
  role: string
}

/**
 * Model User_Profile
 * 
 */
export type User_Profile = {
  id: number
  realName: string
  phoneNo: number
  carrier: string
  alertType: string
  pagerEmail: string
  notificationArea: string
  notificationTypes: string[]
  personalInfo: string
  sendToEmail: boolean
  sendTextNotification: boolean
  sendToPager: boolean
  userId: number
}

/**
 * Model Residence
 * 
 */
export type Residence = {
  id: number
  city: string
  address: string
  state: string
  ZipCode: number
  DateOfBirth: Date
  Occupation: string
  userId: number
}

/**
 * Model Incident
 * 
 */
export type Incident = {
  id: number
  Co_Credit: string
  Country: string
  Time: Date
  Type: string
  Street: string
  City: string
  State: string
  Longitude: number
  Latitude: number
  Zipcode: number
  Text: string
  SMS_Chr_Count: number
  Internal_Note: string
  Confirmed_Incident: boolean
  Queue: boolean
  userId: number
}

/**
 * Model Chat_Messages
 * 
 */
export type Chat_Messages = {
  id: number
  name: string
  Message: string
  createdAt: Date
  userId: number
}

/**
 * Model Admin_Main_Setting
 * 
 */
export type Admin_Main_Setting = {
  id: number
  system_name: string
  backgroundColor: string
  fontColor: string
  alertFormat: string
  state_to_import_wheather_alert: string
  logo: Buffer
  domain: string
  CAD_URL: string
  private_system: boolean
  guest_not_allowed_to_chat: boolean
  theme: string
  fontSize: string
  traineeAlertColor: string
}

/**
 * Model Admin_Email_SMS_Setting
 * 
 */
export type Admin_Email_SMS_Setting = {
  id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.user_Profile`: Exposes CRUD operations for the **User_Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Profiles
    * const user_Profiles = await prisma.user_Profile.findMany()
    * ```
    */
  get user_Profile(): Prisma.User_ProfileDelegate<GlobalReject>;

  /**
   * `prisma.residence`: Exposes CRUD operations for the **Residence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Residences
    * const residences = await prisma.residence.findMany()
    * ```
    */
  get residence(): Prisma.ResidenceDelegate<GlobalReject>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<GlobalReject>;

  /**
   * `prisma.chat_Messages`: Exposes CRUD operations for the **Chat_Messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_Messages
    * const chat_Messages = await prisma.chat_Messages.findMany()
    * ```
    */
  get chat_Messages(): Prisma.Chat_MessagesDelegate<GlobalReject>;

  /**
   * `prisma.admin_Main_Setting`: Exposes CRUD operations for the **Admin_Main_Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_Main_Settings
    * const admin_Main_Settings = await prisma.admin_Main_Setting.findMany()
    * ```
    */
  get admin_Main_Setting(): Prisma.Admin_Main_SettingDelegate<GlobalReject>;

  /**
   * `prisma.admin_Email_SMS_Setting`: Exposes CRUD operations for the **Admin_Email_SMS_Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_Email_SMS_Settings
    * const admin_Email_SMS_Settings = await prisma.admin_Email_SMS_Setting.findMany()
    * ```
    */
  get admin_Email_SMS_Setting(): Prisma.Admin_Email_SMS_SettingDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.2.1
   * Query Engine version: 2920a97877e12e055c1333079b8d19cee7f33826
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    User_Profile: 'User_Profile',
    Residence: 'Residence',
    Incident: 'Incident',
    Chat_Messages: 'Chat_Messages',
    Admin_Main_Setting: 'Admin_Main_Setting',
    Admin_Email_SMS_Setting: 'Admin_Email_SMS_Setting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    User_Profile: number
    Residence: number
    Chat_Messages: number
    Incident: number
  }

  export type UserCountOutputTypeSelect = {
    User_Profile?: boolean
    Residence?: boolean
    Chat_Messages?: boolean
    Incident?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    role: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    User_Profile?: boolean | User_ProfileFindManyArgs
    Residence?: boolean | ResidenceFindManyArgs
    Chat_Messages?: boolean | Chat_MessagesFindManyArgs
    Incident?: boolean | IncidentFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    User_Profile?: boolean | User_ProfileFindManyArgs
    Residence?: boolean | ResidenceFindManyArgs
    Chat_Messages?: boolean | Chat_MessagesFindManyArgs
    Incident?: boolean | IncidentFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'User_Profile' ? Array < User_ProfileGetPayload<S['include'][P]>>  :
        P extends 'Residence' ? Array < ResidenceGetPayload<S['include'][P]>>  :
        P extends 'Chat_Messages' ? Array < Chat_MessagesGetPayload<S['include'][P]>>  :
        P extends 'Incident' ? Array < IncidentGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'User_Profile' ? Array < User_ProfileGetPayload<S['select'][P]>>  :
        P extends 'Residence' ? Array < ResidenceGetPayload<S['select'][P]>>  :
        P extends 'Chat_Messages' ? Array < Chat_MessagesGetPayload<S['select'][P]>>  :
        P extends 'Incident' ? Array < IncidentGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find one User that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User_Profile<T extends User_ProfileFindManyArgs = {}>(args?: Subset<T, User_ProfileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User_Profile>>, PrismaPromise<Array<User_ProfileGetPayload<T>>>>;

    Residence<T extends ResidenceFindManyArgs = {}>(args?: Subset<T, ResidenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Residence>>, PrismaPromise<Array<ResidenceGetPayload<T>>>>;

    Chat_Messages<T extends Chat_MessagesFindManyArgs = {}>(args?: Subset<T, Chat_MessagesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Chat_Messages>>, PrismaPromise<Array<Chat_MessagesGetPayload<T>>>>;

    Incident<T extends IncidentFindManyArgs = {}>(args?: Subset<T, IncidentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Incident>>, PrismaPromise<Array<IncidentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User: findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = UserFindUniqueArgsBase
      

  /**
   * User: findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = UserFindFirstArgsBase
      

  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model User_Profile
   */


  export type AggregateUser_Profile = {
    _count: User_ProfileCountAggregateOutputType | null
    _avg: User_ProfileAvgAggregateOutputType | null
    _sum: User_ProfileSumAggregateOutputType | null
    _min: User_ProfileMinAggregateOutputType | null
    _max: User_ProfileMaxAggregateOutputType | null
  }

  export type User_ProfileAvgAggregateOutputType = {
    id: number | null
    phoneNo: number | null
    userId: number | null
  }

  export type User_ProfileSumAggregateOutputType = {
    id: number | null
    phoneNo: number | null
    userId: number | null
  }

  export type User_ProfileMinAggregateOutputType = {
    id: number | null
    realName: string | null
    phoneNo: number | null
    carrier: string | null
    alertType: string | null
    pagerEmail: string | null
    notificationArea: string | null
    personalInfo: string | null
    sendToEmail: boolean | null
    sendTextNotification: boolean | null
    sendToPager: boolean | null
    userId: number | null
  }

  export type User_ProfileMaxAggregateOutputType = {
    id: number | null
    realName: string | null
    phoneNo: number | null
    carrier: string | null
    alertType: string | null
    pagerEmail: string | null
    notificationArea: string | null
    personalInfo: string | null
    sendToEmail: boolean | null
    sendTextNotification: boolean | null
    sendToPager: boolean | null
    userId: number | null
  }

  export type User_ProfileCountAggregateOutputType = {
    id: number
    realName: number
    phoneNo: number
    carrier: number
    alertType: number
    pagerEmail: number
    notificationArea: number
    notificationTypes: number
    personalInfo: number
    sendToEmail: number
    sendTextNotification: number
    sendToPager: number
    userId: number
    _all: number
  }


  export type User_ProfileAvgAggregateInputType = {
    id?: true
    phoneNo?: true
    userId?: true
  }

  export type User_ProfileSumAggregateInputType = {
    id?: true
    phoneNo?: true
    userId?: true
  }

  export type User_ProfileMinAggregateInputType = {
    id?: true
    realName?: true
    phoneNo?: true
    carrier?: true
    alertType?: true
    pagerEmail?: true
    notificationArea?: true
    personalInfo?: true
    sendToEmail?: true
    sendTextNotification?: true
    sendToPager?: true
    userId?: true
  }

  export type User_ProfileMaxAggregateInputType = {
    id?: true
    realName?: true
    phoneNo?: true
    carrier?: true
    alertType?: true
    pagerEmail?: true
    notificationArea?: true
    personalInfo?: true
    sendToEmail?: true
    sendTextNotification?: true
    sendToPager?: true
    userId?: true
  }

  export type User_ProfileCountAggregateInputType = {
    id?: true
    realName?: true
    phoneNo?: true
    carrier?: true
    alertType?: true
    pagerEmail?: true
    notificationArea?: true
    notificationTypes?: true
    personalInfo?: true
    sendToEmail?: true
    sendTextNotification?: true
    sendToPager?: true
    userId?: true
    _all?: true
  }

  export type User_ProfileAggregateArgs = {
    /**
     * Filter which User_Profile to aggregate.
     * 
    **/
    where?: User_ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<User_ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: User_ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Profiles
    **/
    _count?: true | User_ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_ProfileMaxAggregateInputType
  }

  export type GetUser_ProfileAggregateType<T extends User_ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Profile[P]>
      : GetScalarType<T[P], AggregateUser_Profile[P]>
  }




  export type User_ProfileGroupByArgs = {
    where?: User_ProfileWhereInput
    orderBy?: Enumerable<User_ProfileOrderByWithAggregationInput>
    by: Array<User_ProfileScalarFieldEnum>
    having?: User_ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_ProfileCountAggregateInputType | true
    _avg?: User_ProfileAvgAggregateInputType
    _sum?: User_ProfileSumAggregateInputType
    _min?: User_ProfileMinAggregateInputType
    _max?: User_ProfileMaxAggregateInputType
  }


  export type User_ProfileGroupByOutputType = {
    id: number
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes: string[]
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
    userId: number
    _count: User_ProfileCountAggregateOutputType | null
    _avg: User_ProfileAvgAggregateOutputType | null
    _sum: User_ProfileSumAggregateOutputType | null
    _min: User_ProfileMinAggregateOutputType | null
    _max: User_ProfileMaxAggregateOutputType | null
  }

  type GetUser_ProfileGroupByPayload<T extends User_ProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], User_ProfileGroupByOutputType[P]>
        }
      >
    >


  export type User_ProfileSelect = {
    id?: boolean
    realName?: boolean
    phoneNo?: boolean
    carrier?: boolean
    alertType?: boolean
    pagerEmail?: boolean
    notificationArea?: boolean
    notificationTypes?: boolean
    personalInfo?: boolean
    sendToEmail?: boolean
    sendTextNotification?: boolean
    sendToPager?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type User_ProfileInclude = {
    user?: boolean | UserArgs
  }

  export type User_ProfileGetPayload<
    S extends boolean | null | undefined | User_ProfileArgs,
    U = keyof S
      > = S extends true
        ? User_Profile
    : S extends undefined
    ? never
    : S extends User_ProfileArgs | User_ProfileFindManyArgs
    ?'include' extends U
    ? User_Profile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof User_Profile ? User_Profile[P] : never
  } 
    : User_Profile
  : User_Profile


  type User_ProfileCountArgs = Merge<
    Omit<User_ProfileFindManyArgs, 'select' | 'include'> & {
      select?: User_ProfileCountAggregateInputType | true
    }
  >

  export interface User_ProfileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_Profile that matches the filter.
     * @param {User_ProfileFindUniqueArgs} args - Arguments to find a User_Profile
     * @example
     * // Get one User_Profile
     * const user_Profile = await prisma.user_Profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, User_ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User_Profile'> extends True ? CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>> : CheckSelect<T, Prisma__User_ProfileClient<User_Profile | null >, Prisma__User_ProfileClient<User_ProfileGetPayload<T> | null >>

    /**
     * Find the first User_Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileFindFirstArgs} args - Arguments to find a User_Profile
     * @example
     * // Get one User_Profile
     * const user_Profile = await prisma.user_Profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, User_ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User_Profile'> extends True ? CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>> : CheckSelect<T, Prisma__User_ProfileClient<User_Profile | null >, Prisma__User_ProfileClient<User_ProfileGetPayload<T> | null >>

    /**
     * Find zero or more User_Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Profiles
     * const user_Profiles = await prisma.user_Profile.findMany()
     * 
     * // Get first 10 User_Profiles
     * const user_Profiles = await prisma.user_Profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_ProfileWithIdOnly = await prisma.user_Profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends User_ProfileFindManyArgs>(
      args?: SelectSubset<T, User_ProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User_Profile>>, PrismaPromise<Array<User_ProfileGetPayload<T>>>>

    /**
     * Create a User_Profile.
     * @param {User_ProfileCreateArgs} args - Arguments to create a User_Profile.
     * @example
     * // Create one User_Profile
     * const User_Profile = await prisma.user_Profile.create({
     *   data: {
     *     // ... data to create a User_Profile
     *   }
     * })
     * 
    **/
    create<T extends User_ProfileCreateArgs>(
      args: SelectSubset<T, User_ProfileCreateArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Create many User_Profiles.
     *     @param {User_ProfileCreateManyArgs} args - Arguments to create many User_Profiles.
     *     @example
     *     // Create many User_Profiles
     *     const user_Profile = await prisma.user_Profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends User_ProfileCreateManyArgs>(
      args?: SelectSubset<T, User_ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_Profile.
     * @param {User_ProfileDeleteArgs} args - Arguments to delete one User_Profile.
     * @example
     * // Delete one User_Profile
     * const User_Profile = await prisma.user_Profile.delete({
     *   where: {
     *     // ... filter to delete one User_Profile
     *   }
     * })
     * 
    **/
    delete<T extends User_ProfileDeleteArgs>(
      args: SelectSubset<T, User_ProfileDeleteArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Update one User_Profile.
     * @param {User_ProfileUpdateArgs} args - Arguments to update one User_Profile.
     * @example
     * // Update one User_Profile
     * const user_Profile = await prisma.user_Profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_ProfileUpdateArgs>(
      args: SelectSubset<T, User_ProfileUpdateArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Delete zero or more User_Profiles.
     * @param {User_ProfileDeleteManyArgs} args - Arguments to filter User_Profiles to delete.
     * @example
     * // Delete a few User_Profiles
     * const { count } = await prisma.user_Profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_ProfileDeleteManyArgs>(
      args?: SelectSubset<T, User_ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Profiles
     * const user_Profile = await prisma.user_Profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_ProfileUpdateManyArgs>(
      args: SelectSubset<T, User_ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_Profile.
     * @param {User_ProfileUpsertArgs} args - Arguments to update or create a User_Profile.
     * @example
     * // Update or create a User_Profile
     * const user_Profile = await prisma.user_Profile.upsert({
     *   create: {
     *     // ... data to create a User_Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Profile we want to update
     *   }
     * })
    **/
    upsert<T extends User_ProfileUpsertArgs>(
      args: SelectSubset<T, User_ProfileUpsertArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Find one User_Profile that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {User_ProfileFindUniqueOrThrowArgs} args - Arguments to find a User_Profile
     * @example
     * // Get one User_Profile
     * const user_Profile = await prisma.user_Profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends User_ProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, User_ProfileFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Find the first User_Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileFindFirstOrThrowArgs} args - Arguments to find a User_Profile
     * @example
     * // Get one User_Profile
     * const user_Profile = await prisma.user_Profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends User_ProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, User_ProfileFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__User_ProfileClient<User_Profile>, Prisma__User_ProfileClient<User_ProfileGetPayload<T>>>

    /**
     * Count the number of User_Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileCountArgs} args - Arguments to filter User_Profiles to count.
     * @example
     * // Count the number of User_Profiles
     * const count = await prisma.user_Profile.count({
     *   where: {
     *     // ... the filter for the User_Profiles we want to count
     *   }
     * })
    **/
    count<T extends User_ProfileCountArgs>(
      args?: Subset<T, User_ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_ProfileAggregateArgs>(args: Subset<T, User_ProfileAggregateArgs>): PrismaPromise<GetUser_ProfileAggregateType<T>>

    /**
     * Group by User_Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_ProfileGroupByArgs['orderBy'] }
        : { orderBy?: User_ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_ProfileGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_ProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User_Profile base type for findUnique actions
   */
  export type User_ProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * Filter, which User_Profile to fetch.
     * 
    **/
    where: User_ProfileWhereUniqueInput
  }

  /**
   * User_Profile: findUnique
   */
  export interface User_ProfileFindUniqueArgs extends User_ProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_Profile base type for findFirst actions
   */
  export type User_ProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * Filter, which User_Profile to fetch.
     * 
    **/
    where?: User_ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<User_ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Profiles.
     * 
    **/
    cursor?: User_ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Profiles.
     * 
    **/
    distinct?: Enumerable<User_ProfileScalarFieldEnum>
  }

  /**
   * User_Profile: findFirst
   */
  export interface User_ProfileFindFirstArgs extends User_ProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_Profile findMany
   */
  export type User_ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * Filter, which User_Profiles to fetch.
     * 
    **/
    where?: User_ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<User_ProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Profiles.
     * 
    **/
    cursor?: User_ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_ProfileScalarFieldEnum>
  }


  /**
   * User_Profile create
   */
  export type User_ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * The data needed to create a User_Profile.
     * 
    **/
    data: XOR<User_ProfileCreateInput, User_ProfileUncheckedCreateInput>
  }


  /**
   * User_Profile createMany
   */
  export type User_ProfileCreateManyArgs = {
    /**
     * The data used to create many User_Profiles.
     * 
    **/
    data: Enumerable<User_ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User_Profile update
   */
  export type User_ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * The data needed to update a User_Profile.
     * 
    **/
    data: XOR<User_ProfileUpdateInput, User_ProfileUncheckedUpdateInput>
    /**
     * Choose, which User_Profile to update.
     * 
    **/
    where: User_ProfileWhereUniqueInput
  }


  /**
   * User_Profile updateMany
   */
  export type User_ProfileUpdateManyArgs = {
    /**
     * The data used to update User_Profiles.
     * 
    **/
    data: XOR<User_ProfileUpdateManyMutationInput, User_ProfileUncheckedUpdateManyInput>
    /**
     * Filter which User_Profiles to update
     * 
    **/
    where?: User_ProfileWhereInput
  }


  /**
   * User_Profile upsert
   */
  export type User_ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * The filter to search for the User_Profile to update in case it exists.
     * 
    **/
    where: User_ProfileWhereUniqueInput
    /**
     * In case the User_Profile found by the `where` argument doesn't exist, create a new User_Profile with this data.
     * 
    **/
    create: XOR<User_ProfileCreateInput, User_ProfileUncheckedCreateInput>
    /**
     * In case the User_Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<User_ProfileUpdateInput, User_ProfileUncheckedUpdateInput>
  }


  /**
   * User_Profile delete
   */
  export type User_ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
    /**
     * Filter which User_Profile to delete.
     * 
    **/
    where: User_ProfileWhereUniqueInput
  }


  /**
   * User_Profile deleteMany
   */
  export type User_ProfileDeleteManyArgs = {
    /**
     * Filter which User_Profiles to delete
     * 
    **/
    where?: User_ProfileWhereInput
  }


  /**
   * User_Profile: findUniqueOrThrow
   */
  export type User_ProfileFindUniqueOrThrowArgs = User_ProfileFindUniqueArgsBase
      

  /**
   * User_Profile: findFirstOrThrow
   */
  export type User_ProfileFindFirstOrThrowArgs = User_ProfileFindFirstArgsBase
      

  /**
   * User_Profile without action
   */
  export type User_ProfileArgs = {
    /**
     * Select specific fields to fetch from the User_Profile
     * 
    **/
    select?: User_ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_ProfileInclude | null
  }



  /**
   * Model Residence
   */


  export type AggregateResidence = {
    _count: ResidenceCountAggregateOutputType | null
    _avg: ResidenceAvgAggregateOutputType | null
    _sum: ResidenceSumAggregateOutputType | null
    _min: ResidenceMinAggregateOutputType | null
    _max: ResidenceMaxAggregateOutputType | null
  }

  export type ResidenceAvgAggregateOutputType = {
    id: number | null
    ZipCode: number | null
    userId: number | null
  }

  export type ResidenceSumAggregateOutputType = {
    id: number | null
    ZipCode: number | null
    userId: number | null
  }

  export type ResidenceMinAggregateOutputType = {
    id: number | null
    city: string | null
    address: string | null
    state: string | null
    ZipCode: number | null
    DateOfBirth: Date | null
    Occupation: string | null
    userId: number | null
  }

  export type ResidenceMaxAggregateOutputType = {
    id: number | null
    city: string | null
    address: string | null
    state: string | null
    ZipCode: number | null
    DateOfBirth: Date | null
    Occupation: string | null
    userId: number | null
  }

  export type ResidenceCountAggregateOutputType = {
    id: number
    city: number
    address: number
    state: number
    ZipCode: number
    DateOfBirth: number
    Occupation: number
    userId: number
    _all: number
  }


  export type ResidenceAvgAggregateInputType = {
    id?: true
    ZipCode?: true
    userId?: true
  }

  export type ResidenceSumAggregateInputType = {
    id?: true
    ZipCode?: true
    userId?: true
  }

  export type ResidenceMinAggregateInputType = {
    id?: true
    city?: true
    address?: true
    state?: true
    ZipCode?: true
    DateOfBirth?: true
    Occupation?: true
    userId?: true
  }

  export type ResidenceMaxAggregateInputType = {
    id?: true
    city?: true
    address?: true
    state?: true
    ZipCode?: true
    DateOfBirth?: true
    Occupation?: true
    userId?: true
  }

  export type ResidenceCountAggregateInputType = {
    id?: true
    city?: true
    address?: true
    state?: true
    ZipCode?: true
    DateOfBirth?: true
    Occupation?: true
    userId?: true
    _all?: true
  }

  export type ResidenceAggregateArgs = {
    /**
     * Filter which Residence to aggregate.
     * 
    **/
    where?: ResidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residences to fetch.
     * 
    **/
    orderBy?: Enumerable<ResidenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Residences
    **/
    _count?: true | ResidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResidenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResidenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResidenceMaxAggregateInputType
  }

  export type GetResidenceAggregateType<T extends ResidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateResidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResidence[P]>
      : GetScalarType<T[P], AggregateResidence[P]>
  }




  export type ResidenceGroupByArgs = {
    where?: ResidenceWhereInput
    orderBy?: Enumerable<ResidenceOrderByWithAggregationInput>
    by: Array<ResidenceScalarFieldEnum>
    having?: ResidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResidenceCountAggregateInputType | true
    _avg?: ResidenceAvgAggregateInputType
    _sum?: ResidenceSumAggregateInputType
    _min?: ResidenceMinAggregateInputType
    _max?: ResidenceMaxAggregateInputType
  }


  export type ResidenceGroupByOutputType = {
    id: number
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth: Date
    Occupation: string
    userId: number
    _count: ResidenceCountAggregateOutputType | null
    _avg: ResidenceAvgAggregateOutputType | null
    _sum: ResidenceSumAggregateOutputType | null
    _min: ResidenceMinAggregateOutputType | null
    _max: ResidenceMaxAggregateOutputType | null
  }

  type GetResidenceGroupByPayload<T extends ResidenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResidenceGroupByOutputType[P]>
            : GetScalarType<T[P], ResidenceGroupByOutputType[P]>
        }
      >
    >


  export type ResidenceSelect = {
    id?: boolean
    city?: boolean
    address?: boolean
    state?: boolean
    ZipCode?: boolean
    DateOfBirth?: boolean
    Occupation?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type ResidenceInclude = {
    user?: boolean | UserArgs
  }

  export type ResidenceGetPayload<
    S extends boolean | null | undefined | ResidenceArgs,
    U = keyof S
      > = S extends true
        ? Residence
    : S extends undefined
    ? never
    : S extends ResidenceArgs | ResidenceFindManyArgs
    ?'include' extends U
    ? Residence  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Residence ? Residence[P] : never
  } 
    : Residence
  : Residence


  type ResidenceCountArgs = Merge<
    Omit<ResidenceFindManyArgs, 'select' | 'include'> & {
      select?: ResidenceCountAggregateInputType | true
    }
  >

  export interface ResidenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Residence that matches the filter.
     * @param {ResidenceFindUniqueArgs} args - Arguments to find a Residence
     * @example
     * // Get one Residence
     * const residence = await prisma.residence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResidenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResidenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Residence'> extends True ? CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>> : CheckSelect<T, Prisma__ResidenceClient<Residence | null >, Prisma__ResidenceClient<ResidenceGetPayload<T> | null >>

    /**
     * Find the first Residence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceFindFirstArgs} args - Arguments to find a Residence
     * @example
     * // Get one Residence
     * const residence = await prisma.residence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResidenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResidenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Residence'> extends True ? CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>> : CheckSelect<T, Prisma__ResidenceClient<Residence | null >, Prisma__ResidenceClient<ResidenceGetPayload<T> | null >>

    /**
     * Find zero or more Residences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Residences
     * const residences = await prisma.residence.findMany()
     * 
     * // Get first 10 Residences
     * const residences = await prisma.residence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const residenceWithIdOnly = await prisma.residence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResidenceFindManyArgs>(
      args?: SelectSubset<T, ResidenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Residence>>, PrismaPromise<Array<ResidenceGetPayload<T>>>>

    /**
     * Create a Residence.
     * @param {ResidenceCreateArgs} args - Arguments to create a Residence.
     * @example
     * // Create one Residence
     * const Residence = await prisma.residence.create({
     *   data: {
     *     // ... data to create a Residence
     *   }
     * })
     * 
    **/
    create<T extends ResidenceCreateArgs>(
      args: SelectSubset<T, ResidenceCreateArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Create many Residences.
     *     @param {ResidenceCreateManyArgs} args - Arguments to create many Residences.
     *     @example
     *     // Create many Residences
     *     const residence = await prisma.residence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResidenceCreateManyArgs>(
      args?: SelectSubset<T, ResidenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Residence.
     * @param {ResidenceDeleteArgs} args - Arguments to delete one Residence.
     * @example
     * // Delete one Residence
     * const Residence = await prisma.residence.delete({
     *   where: {
     *     // ... filter to delete one Residence
     *   }
     * })
     * 
    **/
    delete<T extends ResidenceDeleteArgs>(
      args: SelectSubset<T, ResidenceDeleteArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Update one Residence.
     * @param {ResidenceUpdateArgs} args - Arguments to update one Residence.
     * @example
     * // Update one Residence
     * const residence = await prisma.residence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResidenceUpdateArgs>(
      args: SelectSubset<T, ResidenceUpdateArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Delete zero or more Residences.
     * @param {ResidenceDeleteManyArgs} args - Arguments to filter Residences to delete.
     * @example
     * // Delete a few Residences
     * const { count } = await prisma.residence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResidenceDeleteManyArgs>(
      args?: SelectSubset<T, ResidenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Residences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Residences
     * const residence = await prisma.residence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResidenceUpdateManyArgs>(
      args: SelectSubset<T, ResidenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Residence.
     * @param {ResidenceUpsertArgs} args - Arguments to update or create a Residence.
     * @example
     * // Update or create a Residence
     * const residence = await prisma.residence.upsert({
     *   create: {
     *     // ... data to create a Residence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Residence we want to update
     *   }
     * })
    **/
    upsert<T extends ResidenceUpsertArgs>(
      args: SelectSubset<T, ResidenceUpsertArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Find one Residence that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ResidenceFindUniqueOrThrowArgs} args - Arguments to find a Residence
     * @example
     * // Get one Residence
     * const residence = await prisma.residence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResidenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResidenceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Find the first Residence that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceFindFirstOrThrowArgs} args - Arguments to find a Residence
     * @example
     * // Get one Residence
     * const residence = await prisma.residence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResidenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResidenceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ResidenceClient<Residence>, Prisma__ResidenceClient<ResidenceGetPayload<T>>>

    /**
     * Count the number of Residences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceCountArgs} args - Arguments to filter Residences to count.
     * @example
     * // Count the number of Residences
     * const count = await prisma.residence.count({
     *   where: {
     *     // ... the filter for the Residences we want to count
     *   }
     * })
    **/
    count<T extends ResidenceCountArgs>(
      args?: Subset<T, ResidenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Residence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResidenceAggregateArgs>(args: Subset<T, ResidenceAggregateArgs>): PrismaPromise<GetResidenceAggregateType<T>>

    /**
     * Group by Residence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResidenceGroupByArgs['orderBy'] }
        : { orderBy?: ResidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResidenceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Residence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResidenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Residence base type for findUnique actions
   */
  export type ResidenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * Filter, which Residence to fetch.
     * 
    **/
    where: ResidenceWhereUniqueInput
  }

  /**
   * Residence: findUnique
   */
  export interface ResidenceFindUniqueArgs extends ResidenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Residence base type for findFirst actions
   */
  export type ResidenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * Filter, which Residence to fetch.
     * 
    **/
    where?: ResidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residences to fetch.
     * 
    **/
    orderBy?: Enumerable<ResidenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Residences.
     * 
    **/
    cursor?: ResidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Residences.
     * 
    **/
    distinct?: Enumerable<ResidenceScalarFieldEnum>
  }

  /**
   * Residence: findFirst
   */
  export interface ResidenceFindFirstArgs extends ResidenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Residence findMany
   */
  export type ResidenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * Filter, which Residences to fetch.
     * 
    **/
    where?: ResidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Residences to fetch.
     * 
    **/
    orderBy?: Enumerable<ResidenceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Residences.
     * 
    **/
    cursor?: ResidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Residences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Residences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResidenceScalarFieldEnum>
  }


  /**
   * Residence create
   */
  export type ResidenceCreateArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * The data needed to create a Residence.
     * 
    **/
    data: XOR<ResidenceCreateInput, ResidenceUncheckedCreateInput>
  }


  /**
   * Residence createMany
   */
  export type ResidenceCreateManyArgs = {
    /**
     * The data used to create many Residences.
     * 
    **/
    data: Enumerable<ResidenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Residence update
   */
  export type ResidenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * The data needed to update a Residence.
     * 
    **/
    data: XOR<ResidenceUpdateInput, ResidenceUncheckedUpdateInput>
    /**
     * Choose, which Residence to update.
     * 
    **/
    where: ResidenceWhereUniqueInput
  }


  /**
   * Residence updateMany
   */
  export type ResidenceUpdateManyArgs = {
    /**
     * The data used to update Residences.
     * 
    **/
    data: XOR<ResidenceUpdateManyMutationInput, ResidenceUncheckedUpdateManyInput>
    /**
     * Filter which Residences to update
     * 
    **/
    where?: ResidenceWhereInput
  }


  /**
   * Residence upsert
   */
  export type ResidenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * The filter to search for the Residence to update in case it exists.
     * 
    **/
    where: ResidenceWhereUniqueInput
    /**
     * In case the Residence found by the `where` argument doesn't exist, create a new Residence with this data.
     * 
    **/
    create: XOR<ResidenceCreateInput, ResidenceUncheckedCreateInput>
    /**
     * In case the Residence was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResidenceUpdateInput, ResidenceUncheckedUpdateInput>
  }


  /**
   * Residence delete
   */
  export type ResidenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
    /**
     * Filter which Residence to delete.
     * 
    **/
    where: ResidenceWhereUniqueInput
  }


  /**
   * Residence deleteMany
   */
  export type ResidenceDeleteManyArgs = {
    /**
     * Filter which Residences to delete
     * 
    **/
    where?: ResidenceWhereInput
  }


  /**
   * Residence: findUniqueOrThrow
   */
  export type ResidenceFindUniqueOrThrowArgs = ResidenceFindUniqueArgsBase
      

  /**
   * Residence: findFirstOrThrow
   */
  export type ResidenceFindFirstOrThrowArgs = ResidenceFindFirstArgsBase
      

  /**
   * Residence without action
   */
  export type ResidenceArgs = {
    /**
     * Select specific fields to fetch from the Residence
     * 
    **/
    select?: ResidenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ResidenceInclude | null
  }



  /**
   * Model Incident
   */


  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentAvgAggregateOutputType = {
    id: number | null
    Longitude: number | null
    Latitude: number | null
    Zipcode: number | null
    SMS_Chr_Count: number | null
    userId: number | null
  }

  export type IncidentSumAggregateOutputType = {
    id: number | null
    Longitude: number | null
    Latitude: number | null
    Zipcode: number | null
    SMS_Chr_Count: number | null
    userId: number | null
  }

  export type IncidentMinAggregateOutputType = {
    id: number | null
    Co_Credit: string | null
    Country: string | null
    Time: Date | null
    Type: string | null
    Street: string | null
    City: string | null
    State: string | null
    Longitude: number | null
    Latitude: number | null
    Zipcode: number | null
    Text: string | null
    SMS_Chr_Count: number | null
    Internal_Note: string | null
    Confirmed_Incident: boolean | null
    Queue: boolean | null
    userId: number | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: number | null
    Co_Credit: string | null
    Country: string | null
    Time: Date | null
    Type: string | null
    Street: string | null
    City: string | null
    State: string | null
    Longitude: number | null
    Latitude: number | null
    Zipcode: number | null
    Text: string | null
    SMS_Chr_Count: number | null
    Internal_Note: string | null
    Confirmed_Incident: boolean | null
    Queue: boolean | null
    userId: number | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    Co_Credit: number
    Country: number
    Time: number
    Type: number
    Street: number
    City: number
    State: number
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: number
    SMS_Chr_Count: number
    Internal_Note: number
    Confirmed_Incident: number
    Queue: number
    userId: number
    _all: number
  }


  export type IncidentAvgAggregateInputType = {
    id?: true
    Longitude?: true
    Latitude?: true
    Zipcode?: true
    SMS_Chr_Count?: true
    userId?: true
  }

  export type IncidentSumAggregateInputType = {
    id?: true
    Longitude?: true
    Latitude?: true
    Zipcode?: true
    SMS_Chr_Count?: true
    userId?: true
  }

  export type IncidentMinAggregateInputType = {
    id?: true
    Co_Credit?: true
    Country?: true
    Time?: true
    Type?: true
    Street?: true
    City?: true
    State?: true
    Longitude?: true
    Latitude?: true
    Zipcode?: true
    Text?: true
    SMS_Chr_Count?: true
    Internal_Note?: true
    Confirmed_Incident?: true
    Queue?: true
    userId?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    Co_Credit?: true
    Country?: true
    Time?: true
    Type?: true
    Street?: true
    City?: true
    State?: true
    Longitude?: true
    Latitude?: true
    Zipcode?: true
    Text?: true
    SMS_Chr_Count?: true
    Internal_Note?: true
    Confirmed_Incident?: true
    Queue?: true
    userId?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    Co_Credit?: true
    Country?: true
    Time?: true
    Type?: true
    Street?: true
    City?: true
    State?: true
    Longitude?: true
    Latitude?: true
    Zipcode?: true
    Text?: true
    SMS_Chr_Count?: true
    Internal_Note?: true
    Confirmed_Incident?: true
    Queue?: true
    userId?: true
    _all?: true
  }

  export type IncidentAggregateArgs = {
    /**
     * Filter which Incident to aggregate.
     * 
    **/
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     * 
    **/
    orderBy?: Enumerable<IncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncidentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncidentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs = {
    where?: IncidentWhereInput
    orderBy?: Enumerable<IncidentOrderByWithAggregationInput>
    by: Array<IncidentScalarFieldEnum>
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _avg?: IncidentAvgAggregateInputType
    _sum?: IncidentSumAggregateInputType
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }


  export type IncidentGroupByOutputType = {
    id: number
    Co_Credit: string
    Country: string
    Time: Date
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue: boolean
    userId: number
    _count: IncidentCountAggregateOutputType | null
    _avg: IncidentAvgAggregateOutputType | null
    _sum: IncidentSumAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect = {
    id?: boolean
    Co_Credit?: boolean
    Country?: boolean
    Time?: boolean
    Type?: boolean
    Street?: boolean
    City?: boolean
    State?: boolean
    Longitude?: boolean
    Latitude?: boolean
    Zipcode?: boolean
    Text?: boolean
    SMS_Chr_Count?: boolean
    Internal_Note?: boolean
    Confirmed_Incident?: boolean
    Queue?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type IncidentInclude = {
    user?: boolean | UserArgs
  }

  export type IncidentGetPayload<
    S extends boolean | null | undefined | IncidentArgs,
    U = keyof S
      > = S extends true
        ? Incident
    : S extends undefined
    ? never
    : S extends IncidentArgs | IncidentFindManyArgs
    ?'include' extends U
    ? Incident  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Incident ? Incident[P] : never
  } 
    : Incident
  : Incident


  type IncidentCountArgs = Merge<
    Omit<IncidentFindManyArgs, 'select' | 'include'> & {
      select?: IncidentCountAggregateInputType | true
    }
  >

  export interface IncidentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncidentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncidentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Incident'> extends True ? CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>> : CheckSelect<T, Prisma__IncidentClient<Incident | null >, Prisma__IncidentClient<IncidentGetPayload<T> | null >>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncidentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncidentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Incident'> extends True ? CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>> : CheckSelect<T, Prisma__IncidentClient<Incident | null >, Prisma__IncidentClient<IncidentGetPayload<T> | null >>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncidentFindManyArgs>(
      args?: SelectSubset<T, IncidentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Incident>>, PrismaPromise<Array<IncidentGetPayload<T>>>>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
    **/
    create<T extends IncidentCreateArgs>(
      args: SelectSubset<T, IncidentCreateArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Create many Incidents.
     *     @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     *     @example
     *     // Create many Incidents
     *     const incident = await prisma.incident.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncidentCreateManyArgs>(
      args?: SelectSubset<T, IncidentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
    **/
    delete<T extends IncidentDeleteArgs>(
      args: SelectSubset<T, IncidentDeleteArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncidentUpdateArgs>(
      args: SelectSubset<T, IncidentUpdateArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncidentDeleteManyArgs>(
      args?: SelectSubset<T, IncidentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncidentUpdateManyArgs>(
      args: SelectSubset<T, IncidentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
    **/
    upsert<T extends IncidentUpsertArgs>(
      args: SelectSubset<T, IncidentUpsertArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Find one Incident that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, IncidentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Find the first Incident that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, IncidentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__IncidentClient<Incident>, Prisma__IncidentClient<IncidentGetPayload<T>>>

    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncidentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Incident base type for findUnique actions
   */
  export type IncidentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * Filter, which Incident to fetch.
     * 
    **/
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident: findUnique
   */
  export interface IncidentFindUniqueArgs extends IncidentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Incident base type for findFirst actions
   */
  export type IncidentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * Filter, which Incident to fetch.
     * 
    **/
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     * 
    **/
    orderBy?: Enumerable<IncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     * 
    **/
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     * 
    **/
    distinct?: Enumerable<IncidentScalarFieldEnum>
  }

  /**
   * Incident: findFirst
   */
  export interface IncidentFindFirstArgs extends IncidentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * Filter, which Incidents to fetch.
     * 
    **/
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     * 
    **/
    orderBy?: Enumerable<IncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     * 
    **/
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IncidentScalarFieldEnum>
  }


  /**
   * Incident create
   */
  export type IncidentCreateArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * The data needed to create a Incident.
     * 
    **/
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }


  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs = {
    /**
     * The data used to create many Incidents.
     * 
    **/
    data: Enumerable<IncidentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Incident update
   */
  export type IncidentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * The data needed to update a Incident.
     * 
    **/
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     * 
    **/
    where: IncidentWhereUniqueInput
  }


  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs = {
    /**
     * The data used to update Incidents.
     * 
    **/
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     * 
    **/
    where?: IncidentWhereInput
  }


  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * The filter to search for the Incident to update in case it exists.
     * 
    **/
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     * 
    **/
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }


  /**
   * Incident delete
   */
  export type IncidentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
    /**
     * Filter which Incident to delete.
     * 
    **/
    where: IncidentWhereUniqueInput
  }


  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs = {
    /**
     * Filter which Incidents to delete
     * 
    **/
    where?: IncidentWhereInput
  }


  /**
   * Incident: findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs = IncidentFindUniqueArgsBase
      

  /**
   * Incident: findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs = IncidentFindFirstArgsBase
      

  /**
   * Incident without action
   */
  export type IncidentArgs = {
    /**
     * Select specific fields to fetch from the Incident
     * 
    **/
    select?: IncidentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncidentInclude | null
  }



  /**
   * Model Chat_Messages
   */


  export type AggregateChat_Messages = {
    _count: Chat_MessagesCountAggregateOutputType | null
    _avg: Chat_MessagesAvgAggregateOutputType | null
    _sum: Chat_MessagesSumAggregateOutputType | null
    _min: Chat_MessagesMinAggregateOutputType | null
    _max: Chat_MessagesMaxAggregateOutputType | null
  }

  export type Chat_MessagesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Chat_MessagesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Chat_MessagesMinAggregateOutputType = {
    id: number | null
    name: string | null
    Message: string | null
    createdAt: Date | null
    userId: number | null
  }

  export type Chat_MessagesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    Message: string | null
    createdAt: Date | null
    userId: number | null
  }

  export type Chat_MessagesCountAggregateOutputType = {
    id: number
    name: number
    Message: number
    createdAt: number
    userId: number
    _all: number
  }


  export type Chat_MessagesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Chat_MessagesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Chat_MessagesMinAggregateInputType = {
    id?: true
    name?: true
    Message?: true
    createdAt?: true
    userId?: true
  }

  export type Chat_MessagesMaxAggregateInputType = {
    id?: true
    name?: true
    Message?: true
    createdAt?: true
    userId?: true
  }

  export type Chat_MessagesCountAggregateInputType = {
    id?: true
    name?: true
    Message?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type Chat_MessagesAggregateArgs = {
    /**
     * Filter which Chat_Messages to aggregate.
     * 
    **/
    where?: Chat_MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chat_Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<Chat_MessagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Chat_MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chat_Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chat_Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chat_Messages
    **/
    _count?: true | Chat_MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_MessagesMaxAggregateInputType
  }

  export type GetChat_MessagesAggregateType<T extends Chat_MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_Messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_Messages[P]>
      : GetScalarType<T[P], AggregateChat_Messages[P]>
  }




  export type Chat_MessagesGroupByArgs = {
    where?: Chat_MessagesWhereInput
    orderBy?: Enumerable<Chat_MessagesOrderByWithAggregationInput>
    by: Array<Chat_MessagesScalarFieldEnum>
    having?: Chat_MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_MessagesCountAggregateInputType | true
    _avg?: Chat_MessagesAvgAggregateInputType
    _sum?: Chat_MessagesSumAggregateInputType
    _min?: Chat_MessagesMinAggregateInputType
    _max?: Chat_MessagesMaxAggregateInputType
  }


  export type Chat_MessagesGroupByOutputType = {
    id: number
    name: string
    Message: string
    createdAt: Date
    userId: number
    _count: Chat_MessagesCountAggregateOutputType | null
    _avg: Chat_MessagesAvgAggregateOutputType | null
    _sum: Chat_MessagesSumAggregateOutputType | null
    _min: Chat_MessagesMinAggregateOutputType | null
    _max: Chat_MessagesMaxAggregateOutputType | null
  }

  type GetChat_MessagesGroupByPayload<T extends Chat_MessagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Chat_MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_MessagesGroupByOutputType[P]>
        }
      >
    >


  export type Chat_MessagesSelect = {
    id?: boolean
    name?: boolean
    Message?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs
    userId?: boolean
  }

  export type Chat_MessagesInclude = {
    user?: boolean | UserArgs
  }

  export type Chat_MessagesGetPayload<
    S extends boolean | null | undefined | Chat_MessagesArgs,
    U = keyof S
      > = S extends true
        ? Chat_Messages
    : S extends undefined
    ? never
    : S extends Chat_MessagesArgs | Chat_MessagesFindManyArgs
    ?'include' extends U
    ? Chat_Messages  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Chat_Messages ? Chat_Messages[P] : never
  } 
    : Chat_Messages
  : Chat_Messages


  type Chat_MessagesCountArgs = Merge<
    Omit<Chat_MessagesFindManyArgs, 'select' | 'include'> & {
      select?: Chat_MessagesCountAggregateInputType | true
    }
  >

  export interface Chat_MessagesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Chat_Messages that matches the filter.
     * @param {Chat_MessagesFindUniqueArgs} args - Arguments to find a Chat_Messages
     * @example
     * // Get one Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Chat_MessagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Chat_MessagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chat_Messages'> extends True ? CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>> : CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages | null >, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T> | null >>

    /**
     * Find the first Chat_Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesFindFirstArgs} args - Arguments to find a Chat_Messages
     * @example
     * // Get one Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Chat_MessagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Chat_MessagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chat_Messages'> extends True ? CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>> : CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages | null >, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T> | null >>

    /**
     * Find zero or more Chat_Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findMany()
     * 
     * // Get first 10 Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_MessagesWithIdOnly = await prisma.chat_Messages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Chat_MessagesFindManyArgs>(
      args?: SelectSubset<T, Chat_MessagesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Chat_Messages>>, PrismaPromise<Array<Chat_MessagesGetPayload<T>>>>

    /**
     * Create a Chat_Messages.
     * @param {Chat_MessagesCreateArgs} args - Arguments to create a Chat_Messages.
     * @example
     * // Create one Chat_Messages
     * const Chat_Messages = await prisma.chat_Messages.create({
     *   data: {
     *     // ... data to create a Chat_Messages
     *   }
     * })
     * 
    **/
    create<T extends Chat_MessagesCreateArgs>(
      args: SelectSubset<T, Chat_MessagesCreateArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Create many Chat_Messages.
     *     @param {Chat_MessagesCreateManyArgs} args - Arguments to create many Chat_Messages.
     *     @example
     *     // Create many Chat_Messages
     *     const chat_Messages = await prisma.chat_Messages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Chat_MessagesCreateManyArgs>(
      args?: SelectSubset<T, Chat_MessagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Chat_Messages.
     * @param {Chat_MessagesDeleteArgs} args - Arguments to delete one Chat_Messages.
     * @example
     * // Delete one Chat_Messages
     * const Chat_Messages = await prisma.chat_Messages.delete({
     *   where: {
     *     // ... filter to delete one Chat_Messages
     *   }
     * })
     * 
    **/
    delete<T extends Chat_MessagesDeleteArgs>(
      args: SelectSubset<T, Chat_MessagesDeleteArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Update one Chat_Messages.
     * @param {Chat_MessagesUpdateArgs} args - Arguments to update one Chat_Messages.
     * @example
     * // Update one Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Chat_MessagesUpdateArgs>(
      args: SelectSubset<T, Chat_MessagesUpdateArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Delete zero or more Chat_Messages.
     * @param {Chat_MessagesDeleteManyArgs} args - Arguments to filter Chat_Messages to delete.
     * @example
     * // Delete a few Chat_Messages
     * const { count } = await prisma.chat_Messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Chat_MessagesDeleteManyArgs>(
      args?: SelectSubset<T, Chat_MessagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Chat_MessagesUpdateManyArgs>(
      args: SelectSubset<T, Chat_MessagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat_Messages.
     * @param {Chat_MessagesUpsertArgs} args - Arguments to update or create a Chat_Messages.
     * @example
     * // Update or create a Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.upsert({
     *   create: {
     *     // ... data to create a Chat_Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_Messages we want to update
     *   }
     * })
    **/
    upsert<T extends Chat_MessagesUpsertArgs>(
      args: SelectSubset<T, Chat_MessagesUpsertArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Find one Chat_Messages that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Chat_MessagesFindUniqueOrThrowArgs} args - Arguments to find a Chat_Messages
     * @example
     * // Get one Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Chat_MessagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Chat_MessagesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Find the first Chat_Messages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesFindFirstOrThrowArgs} args - Arguments to find a Chat_Messages
     * @example
     * // Get one Chat_Messages
     * const chat_Messages = await prisma.chat_Messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Chat_MessagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Chat_MessagesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Chat_MessagesClient<Chat_Messages>, Prisma__Chat_MessagesClient<Chat_MessagesGetPayload<T>>>

    /**
     * Count the number of Chat_Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesCountArgs} args - Arguments to filter Chat_Messages to count.
     * @example
     * // Count the number of Chat_Messages
     * const count = await prisma.chat_Messages.count({
     *   where: {
     *     // ... the filter for the Chat_Messages we want to count
     *   }
     * })
    **/
    count<T extends Chat_MessagesCountArgs>(
      args?: Subset<T, Chat_MessagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_MessagesAggregateArgs>(args: Subset<T, Chat_MessagesAggregateArgs>): PrismaPromise<GetChat_MessagesAggregateType<T>>

    /**
     * Group by Chat_Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Chat_MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Chat_MessagesGroupByArgs['orderBy'] }
        : { orderBy?: Chat_MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Chat_MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_MessagesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat_Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Chat_MessagesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Chat_Messages base type for findUnique actions
   */
  export type Chat_MessagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * Filter, which Chat_Messages to fetch.
     * 
    **/
    where: Chat_MessagesWhereUniqueInput
  }

  /**
   * Chat_Messages: findUnique
   */
  export interface Chat_MessagesFindUniqueArgs extends Chat_MessagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chat_Messages base type for findFirst actions
   */
  export type Chat_MessagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * Filter, which Chat_Messages to fetch.
     * 
    **/
    where?: Chat_MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chat_Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<Chat_MessagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chat_Messages.
     * 
    **/
    cursor?: Chat_MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chat_Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chat_Messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chat_Messages.
     * 
    **/
    distinct?: Enumerable<Chat_MessagesScalarFieldEnum>
  }

  /**
   * Chat_Messages: findFirst
   */
  export interface Chat_MessagesFindFirstArgs extends Chat_MessagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chat_Messages findMany
   */
  export type Chat_MessagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * Filter, which Chat_Messages to fetch.
     * 
    **/
    where?: Chat_MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chat_Messages to fetch.
     * 
    **/
    orderBy?: Enumerable<Chat_MessagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chat_Messages.
     * 
    **/
    cursor?: Chat_MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chat_Messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chat_Messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Chat_MessagesScalarFieldEnum>
  }


  /**
   * Chat_Messages create
   */
  export type Chat_MessagesCreateArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * The data needed to create a Chat_Messages.
     * 
    **/
    data: XOR<Chat_MessagesCreateInput, Chat_MessagesUncheckedCreateInput>
  }


  /**
   * Chat_Messages createMany
   */
  export type Chat_MessagesCreateManyArgs = {
    /**
     * The data used to create many Chat_Messages.
     * 
    **/
    data: Enumerable<Chat_MessagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chat_Messages update
   */
  export type Chat_MessagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * The data needed to update a Chat_Messages.
     * 
    **/
    data: XOR<Chat_MessagesUpdateInput, Chat_MessagesUncheckedUpdateInput>
    /**
     * Choose, which Chat_Messages to update.
     * 
    **/
    where: Chat_MessagesWhereUniqueInput
  }


  /**
   * Chat_Messages updateMany
   */
  export type Chat_MessagesUpdateManyArgs = {
    /**
     * The data used to update Chat_Messages.
     * 
    **/
    data: XOR<Chat_MessagesUpdateManyMutationInput, Chat_MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Chat_Messages to update
     * 
    **/
    where?: Chat_MessagesWhereInput
  }


  /**
   * Chat_Messages upsert
   */
  export type Chat_MessagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * The filter to search for the Chat_Messages to update in case it exists.
     * 
    **/
    where: Chat_MessagesWhereUniqueInput
    /**
     * In case the Chat_Messages found by the `where` argument doesn't exist, create a new Chat_Messages with this data.
     * 
    **/
    create: XOR<Chat_MessagesCreateInput, Chat_MessagesUncheckedCreateInput>
    /**
     * In case the Chat_Messages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Chat_MessagesUpdateInput, Chat_MessagesUncheckedUpdateInput>
  }


  /**
   * Chat_Messages delete
   */
  export type Chat_MessagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
    /**
     * Filter which Chat_Messages to delete.
     * 
    **/
    where: Chat_MessagesWhereUniqueInput
  }


  /**
   * Chat_Messages deleteMany
   */
  export type Chat_MessagesDeleteManyArgs = {
    /**
     * Filter which Chat_Messages to delete
     * 
    **/
    where?: Chat_MessagesWhereInput
  }


  /**
   * Chat_Messages: findUniqueOrThrow
   */
  export type Chat_MessagesFindUniqueOrThrowArgs = Chat_MessagesFindUniqueArgsBase
      

  /**
   * Chat_Messages: findFirstOrThrow
   */
  export type Chat_MessagesFindFirstOrThrowArgs = Chat_MessagesFindFirstArgsBase
      

  /**
   * Chat_Messages without action
   */
  export type Chat_MessagesArgs = {
    /**
     * Select specific fields to fetch from the Chat_Messages
     * 
    **/
    select?: Chat_MessagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Chat_MessagesInclude | null
  }



  /**
   * Model Admin_Main_Setting
   */


  export type AggregateAdmin_Main_Setting = {
    _count: Admin_Main_SettingCountAggregateOutputType | null
    _avg: Admin_Main_SettingAvgAggregateOutputType | null
    _sum: Admin_Main_SettingSumAggregateOutputType | null
    _min: Admin_Main_SettingMinAggregateOutputType | null
    _max: Admin_Main_SettingMaxAggregateOutputType | null
  }

  export type Admin_Main_SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type Admin_Main_SettingSumAggregateOutputType = {
    id: number | null
  }

  export type Admin_Main_SettingMinAggregateOutputType = {
    id: number | null
    system_name: string | null
    backgroundColor: string | null
    fontColor: string | null
    alertFormat: string | null
    state_to_import_wheather_alert: string | null
    logo: Buffer | null
    domain: string | null
    CAD_URL: string | null
    private_system: boolean | null
    guest_not_allowed_to_chat: boolean | null
    theme: string | null
    fontSize: string | null
    traineeAlertColor: string | null
  }

  export type Admin_Main_SettingMaxAggregateOutputType = {
    id: number | null
    system_name: string | null
    backgroundColor: string | null
    fontColor: string | null
    alertFormat: string | null
    state_to_import_wheather_alert: string | null
    logo: Buffer | null
    domain: string | null
    CAD_URL: string | null
    private_system: boolean | null
    guest_not_allowed_to_chat: boolean | null
    theme: string | null
    fontSize: string | null
    traineeAlertColor: string | null
  }

  export type Admin_Main_SettingCountAggregateOutputType = {
    id: number
    system_name: number
    backgroundColor: number
    fontColor: number
    alertFormat: number
    state_to_import_wheather_alert: number
    logo: number
    domain: number
    CAD_URL: number
    private_system: number
    guest_not_allowed_to_chat: number
    theme: number
    fontSize: number
    traineeAlertColor: number
    _all: number
  }


  export type Admin_Main_SettingAvgAggregateInputType = {
    id?: true
  }

  export type Admin_Main_SettingSumAggregateInputType = {
    id?: true
  }

  export type Admin_Main_SettingMinAggregateInputType = {
    id?: true
    system_name?: true
    backgroundColor?: true
    fontColor?: true
    alertFormat?: true
    state_to_import_wheather_alert?: true
    logo?: true
    domain?: true
    CAD_URL?: true
    private_system?: true
    guest_not_allowed_to_chat?: true
    theme?: true
    fontSize?: true
    traineeAlertColor?: true
  }

  export type Admin_Main_SettingMaxAggregateInputType = {
    id?: true
    system_name?: true
    backgroundColor?: true
    fontColor?: true
    alertFormat?: true
    state_to_import_wheather_alert?: true
    logo?: true
    domain?: true
    CAD_URL?: true
    private_system?: true
    guest_not_allowed_to_chat?: true
    theme?: true
    fontSize?: true
    traineeAlertColor?: true
  }

  export type Admin_Main_SettingCountAggregateInputType = {
    id?: true
    system_name?: true
    backgroundColor?: true
    fontColor?: true
    alertFormat?: true
    state_to_import_wheather_alert?: true
    logo?: true
    domain?: true
    CAD_URL?: true
    private_system?: true
    guest_not_allowed_to_chat?: true
    theme?: true
    fontSize?: true
    traineeAlertColor?: true
    _all?: true
  }

  export type Admin_Main_SettingAggregateArgs = {
    /**
     * Filter which Admin_Main_Setting to aggregate.
     * 
    **/
    where?: Admin_Main_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Main_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Main_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Admin_Main_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Main_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Main_Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admin_Main_Settings
    **/
    _count?: true | Admin_Main_SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_Main_SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_Main_SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_Main_SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_Main_SettingMaxAggregateInputType
  }

  export type GetAdmin_Main_SettingAggregateType<T extends Admin_Main_SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_Main_Setting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_Main_Setting[P]>
      : GetScalarType<T[P], AggregateAdmin_Main_Setting[P]>
  }




  export type Admin_Main_SettingGroupByArgs = {
    where?: Admin_Main_SettingWhereInput
    orderBy?: Enumerable<Admin_Main_SettingOrderByWithAggregationInput>
    by: Array<Admin_Main_SettingScalarFieldEnum>
    having?: Admin_Main_SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_Main_SettingCountAggregateInputType | true
    _avg?: Admin_Main_SettingAvgAggregateInputType
    _sum?: Admin_Main_SettingSumAggregateInputType
    _min?: Admin_Main_SettingMinAggregateInputType
    _max?: Admin_Main_SettingMaxAggregateInputType
  }


  export type Admin_Main_SettingGroupByOutputType = {
    id: number
    system_name: string
    backgroundColor: string
    fontColor: string
    alertFormat: string
    state_to_import_wheather_alert: string
    logo: Buffer
    domain: string
    CAD_URL: string
    private_system: boolean
    guest_not_allowed_to_chat: boolean
    theme: string
    fontSize: string
    traineeAlertColor: string
    _count: Admin_Main_SettingCountAggregateOutputType | null
    _avg: Admin_Main_SettingAvgAggregateOutputType | null
    _sum: Admin_Main_SettingSumAggregateOutputType | null
    _min: Admin_Main_SettingMinAggregateOutputType | null
    _max: Admin_Main_SettingMaxAggregateOutputType | null
  }

  type GetAdmin_Main_SettingGroupByPayload<T extends Admin_Main_SettingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_Main_SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_Main_SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_Main_SettingGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_Main_SettingGroupByOutputType[P]>
        }
      >
    >


  export type Admin_Main_SettingSelect = {
    id?: boolean
    system_name?: boolean
    backgroundColor?: boolean
    fontColor?: boolean
    alertFormat?: boolean
    state_to_import_wheather_alert?: boolean
    logo?: boolean
    domain?: boolean
    CAD_URL?: boolean
    private_system?: boolean
    guest_not_allowed_to_chat?: boolean
    theme?: boolean
    fontSize?: boolean
    traineeAlertColor?: boolean
  }

  export type Admin_Main_SettingGetPayload<
    S extends boolean | null | undefined | Admin_Main_SettingArgs,
    U = keyof S
      > = S extends true
        ? Admin_Main_Setting
    : S extends undefined
    ? never
    : S extends Admin_Main_SettingArgs | Admin_Main_SettingFindManyArgs
    ?'include' extends U
    ? Admin_Main_Setting 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin_Main_Setting ? Admin_Main_Setting[P] : never
  } 
    : Admin_Main_Setting
  : Admin_Main_Setting


  type Admin_Main_SettingCountArgs = Merge<
    Omit<Admin_Main_SettingFindManyArgs, 'select' | 'include'> & {
      select?: Admin_Main_SettingCountAggregateInputType | true
    }
  >

  export interface Admin_Main_SettingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin_Main_Setting that matches the filter.
     * @param {Admin_Main_SettingFindUniqueArgs} args - Arguments to find a Admin_Main_Setting
     * @example
     * // Get one Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Admin_Main_SettingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Admin_Main_SettingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin_Main_Setting'> extends True ? CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>> : CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting | null >, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T> | null >>

    /**
     * Find the first Admin_Main_Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingFindFirstArgs} args - Arguments to find a Admin_Main_Setting
     * @example
     * // Get one Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Admin_Main_SettingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Admin_Main_SettingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin_Main_Setting'> extends True ? CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>> : CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting | null >, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T> | null >>

    /**
     * Find zero or more Admin_Main_Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_Main_Settings
     * const admin_Main_Settings = await prisma.admin_Main_Setting.findMany()
     * 
     * // Get first 10 Admin_Main_Settings
     * const admin_Main_Settings = await prisma.admin_Main_Setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_Main_SettingWithIdOnly = await prisma.admin_Main_Setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Admin_Main_SettingFindManyArgs>(
      args?: SelectSubset<T, Admin_Main_SettingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admin_Main_Setting>>, PrismaPromise<Array<Admin_Main_SettingGetPayload<T>>>>

    /**
     * Create a Admin_Main_Setting.
     * @param {Admin_Main_SettingCreateArgs} args - Arguments to create a Admin_Main_Setting.
     * @example
     * // Create one Admin_Main_Setting
     * const Admin_Main_Setting = await prisma.admin_Main_Setting.create({
     *   data: {
     *     // ... data to create a Admin_Main_Setting
     *   }
     * })
     * 
    **/
    create<T extends Admin_Main_SettingCreateArgs>(
      args: SelectSubset<T, Admin_Main_SettingCreateArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Create many Admin_Main_Settings.
     *     @param {Admin_Main_SettingCreateManyArgs} args - Arguments to create many Admin_Main_Settings.
     *     @example
     *     // Create many Admin_Main_Settings
     *     const admin_Main_Setting = await prisma.admin_Main_Setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Admin_Main_SettingCreateManyArgs>(
      args?: SelectSubset<T, Admin_Main_SettingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_Main_Setting.
     * @param {Admin_Main_SettingDeleteArgs} args - Arguments to delete one Admin_Main_Setting.
     * @example
     * // Delete one Admin_Main_Setting
     * const Admin_Main_Setting = await prisma.admin_Main_Setting.delete({
     *   where: {
     *     // ... filter to delete one Admin_Main_Setting
     *   }
     * })
     * 
    **/
    delete<T extends Admin_Main_SettingDeleteArgs>(
      args: SelectSubset<T, Admin_Main_SettingDeleteArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Update one Admin_Main_Setting.
     * @param {Admin_Main_SettingUpdateArgs} args - Arguments to update one Admin_Main_Setting.
     * @example
     * // Update one Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Admin_Main_SettingUpdateArgs>(
      args: SelectSubset<T, Admin_Main_SettingUpdateArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Delete zero or more Admin_Main_Settings.
     * @param {Admin_Main_SettingDeleteManyArgs} args - Arguments to filter Admin_Main_Settings to delete.
     * @example
     * // Delete a few Admin_Main_Settings
     * const { count } = await prisma.admin_Main_Setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Admin_Main_SettingDeleteManyArgs>(
      args?: SelectSubset<T, Admin_Main_SettingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_Main_Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_Main_Settings
     * const admin_Main_Setting = await prisma.admin_Main_Setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Admin_Main_SettingUpdateManyArgs>(
      args: SelectSubset<T, Admin_Main_SettingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_Main_Setting.
     * @param {Admin_Main_SettingUpsertArgs} args - Arguments to update or create a Admin_Main_Setting.
     * @example
     * // Update or create a Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.upsert({
     *   create: {
     *     // ... data to create a Admin_Main_Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_Main_Setting we want to update
     *   }
     * })
    **/
    upsert<T extends Admin_Main_SettingUpsertArgs>(
      args: SelectSubset<T, Admin_Main_SettingUpsertArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Find one Admin_Main_Setting that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Admin_Main_SettingFindUniqueOrThrowArgs} args - Arguments to find a Admin_Main_Setting
     * @example
     * // Get one Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Admin_Main_SettingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Admin_Main_SettingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Find the first Admin_Main_Setting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingFindFirstOrThrowArgs} args - Arguments to find a Admin_Main_Setting
     * @example
     * // Get one Admin_Main_Setting
     * const admin_Main_Setting = await prisma.admin_Main_Setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Admin_Main_SettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Admin_Main_SettingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Admin_Main_SettingClient<Admin_Main_Setting>, Prisma__Admin_Main_SettingClient<Admin_Main_SettingGetPayload<T>>>

    /**
     * Count the number of Admin_Main_Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingCountArgs} args - Arguments to filter Admin_Main_Settings to count.
     * @example
     * // Count the number of Admin_Main_Settings
     * const count = await prisma.admin_Main_Setting.count({
     *   where: {
     *     // ... the filter for the Admin_Main_Settings we want to count
     *   }
     * })
    **/
    count<T extends Admin_Main_SettingCountArgs>(
      args?: Subset<T, Admin_Main_SettingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_Main_SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_Main_Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_Main_SettingAggregateArgs>(args: Subset<T, Admin_Main_SettingAggregateArgs>): PrismaPromise<GetAdmin_Main_SettingAggregateType<T>>

    /**
     * Group by Admin_Main_Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Main_SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_Main_SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_Main_SettingGroupByArgs['orderBy'] }
        : { orderBy?: Admin_Main_SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_Main_SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_Main_SettingGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin_Main_Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Admin_Main_SettingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin_Main_Setting base type for findUnique actions
   */
  export type Admin_Main_SettingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * Filter, which Admin_Main_Setting to fetch.
     * 
    **/
    where: Admin_Main_SettingWhereUniqueInput
  }

  /**
   * Admin_Main_Setting: findUnique
   */
  export interface Admin_Main_SettingFindUniqueArgs extends Admin_Main_SettingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin_Main_Setting base type for findFirst actions
   */
  export type Admin_Main_SettingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * Filter, which Admin_Main_Setting to fetch.
     * 
    **/
    where?: Admin_Main_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Main_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Main_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admin_Main_Settings.
     * 
    **/
    cursor?: Admin_Main_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Main_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Main_Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admin_Main_Settings.
     * 
    **/
    distinct?: Enumerable<Admin_Main_SettingScalarFieldEnum>
  }

  /**
   * Admin_Main_Setting: findFirst
   */
  export interface Admin_Main_SettingFindFirstArgs extends Admin_Main_SettingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin_Main_Setting findMany
   */
  export type Admin_Main_SettingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * Filter, which Admin_Main_Settings to fetch.
     * 
    **/
    where?: Admin_Main_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Main_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Main_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admin_Main_Settings.
     * 
    **/
    cursor?: Admin_Main_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Main_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Main_Settings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_Main_SettingScalarFieldEnum>
  }


  /**
   * Admin_Main_Setting create
   */
  export type Admin_Main_SettingCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * The data needed to create a Admin_Main_Setting.
     * 
    **/
    data: XOR<Admin_Main_SettingCreateInput, Admin_Main_SettingUncheckedCreateInput>
  }


  /**
   * Admin_Main_Setting createMany
   */
  export type Admin_Main_SettingCreateManyArgs = {
    /**
     * The data used to create many Admin_Main_Settings.
     * 
    **/
    data: Enumerable<Admin_Main_SettingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin_Main_Setting update
   */
  export type Admin_Main_SettingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * The data needed to update a Admin_Main_Setting.
     * 
    **/
    data: XOR<Admin_Main_SettingUpdateInput, Admin_Main_SettingUncheckedUpdateInput>
    /**
     * Choose, which Admin_Main_Setting to update.
     * 
    **/
    where: Admin_Main_SettingWhereUniqueInput
  }


  /**
   * Admin_Main_Setting updateMany
   */
  export type Admin_Main_SettingUpdateManyArgs = {
    /**
     * The data used to update Admin_Main_Settings.
     * 
    **/
    data: XOR<Admin_Main_SettingUpdateManyMutationInput, Admin_Main_SettingUncheckedUpdateManyInput>
    /**
     * Filter which Admin_Main_Settings to update
     * 
    **/
    where?: Admin_Main_SettingWhereInput
  }


  /**
   * Admin_Main_Setting upsert
   */
  export type Admin_Main_SettingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * The filter to search for the Admin_Main_Setting to update in case it exists.
     * 
    **/
    where: Admin_Main_SettingWhereUniqueInput
    /**
     * In case the Admin_Main_Setting found by the `where` argument doesn't exist, create a new Admin_Main_Setting with this data.
     * 
    **/
    create: XOR<Admin_Main_SettingCreateInput, Admin_Main_SettingUncheckedCreateInput>
    /**
     * In case the Admin_Main_Setting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Admin_Main_SettingUpdateInput, Admin_Main_SettingUncheckedUpdateInput>
  }


  /**
   * Admin_Main_Setting delete
   */
  export type Admin_Main_SettingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
    /**
     * Filter which Admin_Main_Setting to delete.
     * 
    **/
    where: Admin_Main_SettingWhereUniqueInput
  }


  /**
   * Admin_Main_Setting deleteMany
   */
  export type Admin_Main_SettingDeleteManyArgs = {
    /**
     * Filter which Admin_Main_Settings to delete
     * 
    **/
    where?: Admin_Main_SettingWhereInput
  }


  /**
   * Admin_Main_Setting: findUniqueOrThrow
   */
  export type Admin_Main_SettingFindUniqueOrThrowArgs = Admin_Main_SettingFindUniqueArgsBase
      

  /**
   * Admin_Main_Setting: findFirstOrThrow
   */
  export type Admin_Main_SettingFindFirstOrThrowArgs = Admin_Main_SettingFindFirstArgsBase
      

  /**
   * Admin_Main_Setting without action
   */
  export type Admin_Main_SettingArgs = {
    /**
     * Select specific fields to fetch from the Admin_Main_Setting
     * 
    **/
    select?: Admin_Main_SettingSelect | null
  }



  /**
   * Model Admin_Email_SMS_Setting
   */


  export type AggregateAdmin_Email_SMS_Setting = {
    _count: Admin_Email_SMS_SettingCountAggregateOutputType | null
    _avg: Admin_Email_SMS_SettingAvgAggregateOutputType | null
    _sum: Admin_Email_SMS_SettingSumAggregateOutputType | null
    _min: Admin_Email_SMS_SettingMinAggregateOutputType | null
    _max: Admin_Email_SMS_SettingMaxAggregateOutputType | null
  }

  export type Admin_Email_SMS_SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type Admin_Email_SMS_SettingSumAggregateOutputType = {
    id: number | null
  }

  export type Admin_Email_SMS_SettingMinAggregateOutputType = {
    id: number | null
  }

  export type Admin_Email_SMS_SettingMaxAggregateOutputType = {
    id: number | null
  }

  export type Admin_Email_SMS_SettingCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Admin_Email_SMS_SettingAvgAggregateInputType = {
    id?: true
  }

  export type Admin_Email_SMS_SettingSumAggregateInputType = {
    id?: true
  }

  export type Admin_Email_SMS_SettingMinAggregateInputType = {
    id?: true
  }

  export type Admin_Email_SMS_SettingMaxAggregateInputType = {
    id?: true
  }

  export type Admin_Email_SMS_SettingCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Admin_Email_SMS_SettingAggregateArgs = {
    /**
     * Filter which Admin_Email_SMS_Setting to aggregate.
     * 
    **/
    where?: Admin_Email_SMS_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Email_SMS_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Email_SMS_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Admin_Email_SMS_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Email_SMS_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Email_SMS_Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admin_Email_SMS_Settings
    **/
    _count?: true | Admin_Email_SMS_SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_Email_SMS_SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_Email_SMS_SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_Email_SMS_SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_Email_SMS_SettingMaxAggregateInputType
  }

  export type GetAdmin_Email_SMS_SettingAggregateType<T extends Admin_Email_SMS_SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_Email_SMS_Setting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_Email_SMS_Setting[P]>
      : GetScalarType<T[P], AggregateAdmin_Email_SMS_Setting[P]>
  }




  export type Admin_Email_SMS_SettingGroupByArgs = {
    where?: Admin_Email_SMS_SettingWhereInput
    orderBy?: Enumerable<Admin_Email_SMS_SettingOrderByWithAggregationInput>
    by: Array<Admin_Email_SMS_SettingScalarFieldEnum>
    having?: Admin_Email_SMS_SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_Email_SMS_SettingCountAggregateInputType | true
    _avg?: Admin_Email_SMS_SettingAvgAggregateInputType
    _sum?: Admin_Email_SMS_SettingSumAggregateInputType
    _min?: Admin_Email_SMS_SettingMinAggregateInputType
    _max?: Admin_Email_SMS_SettingMaxAggregateInputType
  }


  export type Admin_Email_SMS_SettingGroupByOutputType = {
    id: number
    _count: Admin_Email_SMS_SettingCountAggregateOutputType | null
    _avg: Admin_Email_SMS_SettingAvgAggregateOutputType | null
    _sum: Admin_Email_SMS_SettingSumAggregateOutputType | null
    _min: Admin_Email_SMS_SettingMinAggregateOutputType | null
    _max: Admin_Email_SMS_SettingMaxAggregateOutputType | null
  }

  type GetAdmin_Email_SMS_SettingGroupByPayload<T extends Admin_Email_SMS_SettingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_Email_SMS_SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_Email_SMS_SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_Email_SMS_SettingGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_Email_SMS_SettingGroupByOutputType[P]>
        }
      >
    >


  export type Admin_Email_SMS_SettingSelect = {
    id?: boolean
  }

  export type Admin_Email_SMS_SettingGetPayload<
    S extends boolean | null | undefined | Admin_Email_SMS_SettingArgs,
    U = keyof S
      > = S extends true
        ? Admin_Email_SMS_Setting
    : S extends undefined
    ? never
    : S extends Admin_Email_SMS_SettingArgs | Admin_Email_SMS_SettingFindManyArgs
    ?'include' extends U
    ? Admin_Email_SMS_Setting 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin_Email_SMS_Setting ? Admin_Email_SMS_Setting[P] : never
  } 
    : Admin_Email_SMS_Setting
  : Admin_Email_SMS_Setting


  type Admin_Email_SMS_SettingCountArgs = Merge<
    Omit<Admin_Email_SMS_SettingFindManyArgs, 'select' | 'include'> & {
      select?: Admin_Email_SMS_SettingCountAggregateInputType | true
    }
  >

  export interface Admin_Email_SMS_SettingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admin_Email_SMS_Setting that matches the filter.
     * @param {Admin_Email_SMS_SettingFindUniqueArgs} args - Arguments to find a Admin_Email_SMS_Setting
     * @example
     * // Get one Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Admin_Email_SMS_SettingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Admin_Email_SMS_SettingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin_Email_SMS_Setting'> extends True ? CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>> : CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting | null >, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T> | null >>

    /**
     * Find the first Admin_Email_SMS_Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingFindFirstArgs} args - Arguments to find a Admin_Email_SMS_Setting
     * @example
     * // Get one Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Admin_Email_SMS_SettingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin_Email_SMS_Setting'> extends True ? CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>> : CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting | null >, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T> | null >>

    /**
     * Find zero or more Admin_Email_SMS_Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_Email_SMS_Settings
     * const admin_Email_SMS_Settings = await prisma.admin_Email_SMS_Setting.findMany()
     * 
     * // Get first 10 Admin_Email_SMS_Settings
     * const admin_Email_SMS_Settings = await prisma.admin_Email_SMS_Setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_Email_SMS_SettingWithIdOnly = await prisma.admin_Email_SMS_Setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Admin_Email_SMS_SettingFindManyArgs>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admin_Email_SMS_Setting>>, PrismaPromise<Array<Admin_Email_SMS_SettingGetPayload<T>>>>

    /**
     * Create a Admin_Email_SMS_Setting.
     * @param {Admin_Email_SMS_SettingCreateArgs} args - Arguments to create a Admin_Email_SMS_Setting.
     * @example
     * // Create one Admin_Email_SMS_Setting
     * const Admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.create({
     *   data: {
     *     // ... data to create a Admin_Email_SMS_Setting
     *   }
     * })
     * 
    **/
    create<T extends Admin_Email_SMS_SettingCreateArgs>(
      args: SelectSubset<T, Admin_Email_SMS_SettingCreateArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Create many Admin_Email_SMS_Settings.
     *     @param {Admin_Email_SMS_SettingCreateManyArgs} args - Arguments to create many Admin_Email_SMS_Settings.
     *     @example
     *     // Create many Admin_Email_SMS_Settings
     *     const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Admin_Email_SMS_SettingCreateManyArgs>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_Email_SMS_Setting.
     * @param {Admin_Email_SMS_SettingDeleteArgs} args - Arguments to delete one Admin_Email_SMS_Setting.
     * @example
     * // Delete one Admin_Email_SMS_Setting
     * const Admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.delete({
     *   where: {
     *     // ... filter to delete one Admin_Email_SMS_Setting
     *   }
     * })
     * 
    **/
    delete<T extends Admin_Email_SMS_SettingDeleteArgs>(
      args: SelectSubset<T, Admin_Email_SMS_SettingDeleteArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Update one Admin_Email_SMS_Setting.
     * @param {Admin_Email_SMS_SettingUpdateArgs} args - Arguments to update one Admin_Email_SMS_Setting.
     * @example
     * // Update one Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Admin_Email_SMS_SettingUpdateArgs>(
      args: SelectSubset<T, Admin_Email_SMS_SettingUpdateArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Delete zero or more Admin_Email_SMS_Settings.
     * @param {Admin_Email_SMS_SettingDeleteManyArgs} args - Arguments to filter Admin_Email_SMS_Settings to delete.
     * @example
     * // Delete a few Admin_Email_SMS_Settings
     * const { count } = await prisma.admin_Email_SMS_Setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Admin_Email_SMS_SettingDeleteManyArgs>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_Email_SMS_Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_Email_SMS_Settings
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Admin_Email_SMS_SettingUpdateManyArgs>(
      args: SelectSubset<T, Admin_Email_SMS_SettingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_Email_SMS_Setting.
     * @param {Admin_Email_SMS_SettingUpsertArgs} args - Arguments to update or create a Admin_Email_SMS_Setting.
     * @example
     * // Update or create a Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.upsert({
     *   create: {
     *     // ... data to create a Admin_Email_SMS_Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_Email_SMS_Setting we want to update
     *   }
     * })
    **/
    upsert<T extends Admin_Email_SMS_SettingUpsertArgs>(
      args: SelectSubset<T, Admin_Email_SMS_SettingUpsertArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Find one Admin_Email_SMS_Setting that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {Admin_Email_SMS_SettingFindUniqueOrThrowArgs} args - Arguments to find a Admin_Email_SMS_Setting
     * @example
     * // Get one Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Admin_Email_SMS_SettingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Find the first Admin_Email_SMS_Setting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingFindFirstOrThrowArgs} args - Arguments to find a Admin_Email_SMS_Setting
     * @example
     * // Get one Admin_Email_SMS_Setting
     * const admin_Email_SMS_Setting = await prisma.admin_Email_SMS_Setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Admin_Email_SMS_SettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Admin_Email_SMS_SettingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_Setting>, Prisma__Admin_Email_SMS_SettingClient<Admin_Email_SMS_SettingGetPayload<T>>>

    /**
     * Count the number of Admin_Email_SMS_Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingCountArgs} args - Arguments to filter Admin_Email_SMS_Settings to count.
     * @example
     * // Count the number of Admin_Email_SMS_Settings
     * const count = await prisma.admin_Email_SMS_Setting.count({
     *   where: {
     *     // ... the filter for the Admin_Email_SMS_Settings we want to count
     *   }
     * })
    **/
    count<T extends Admin_Email_SMS_SettingCountArgs>(
      args?: Subset<T, Admin_Email_SMS_SettingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_Email_SMS_SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_Email_SMS_Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_Email_SMS_SettingAggregateArgs>(args: Subset<T, Admin_Email_SMS_SettingAggregateArgs>): PrismaPromise<GetAdmin_Email_SMS_SettingAggregateType<T>>

    /**
     * Group by Admin_Email_SMS_Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_Email_SMS_SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_Email_SMS_SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_Email_SMS_SettingGroupByArgs['orderBy'] }
        : { orderBy?: Admin_Email_SMS_SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_Email_SMS_SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_Email_SMS_SettingGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin_Email_SMS_Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Admin_Email_SMS_SettingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admin_Email_SMS_Setting base type for findUnique actions
   */
  export type Admin_Email_SMS_SettingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * Filter, which Admin_Email_SMS_Setting to fetch.
     * 
    **/
    where: Admin_Email_SMS_SettingWhereUniqueInput
  }

  /**
   * Admin_Email_SMS_Setting: findUnique
   */
  export interface Admin_Email_SMS_SettingFindUniqueArgs extends Admin_Email_SMS_SettingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin_Email_SMS_Setting base type for findFirst actions
   */
  export type Admin_Email_SMS_SettingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * Filter, which Admin_Email_SMS_Setting to fetch.
     * 
    **/
    where?: Admin_Email_SMS_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Email_SMS_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Email_SMS_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admin_Email_SMS_Settings.
     * 
    **/
    cursor?: Admin_Email_SMS_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Email_SMS_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Email_SMS_Settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admin_Email_SMS_Settings.
     * 
    **/
    distinct?: Enumerable<Admin_Email_SMS_SettingScalarFieldEnum>
  }

  /**
   * Admin_Email_SMS_Setting: findFirst
   */
  export interface Admin_Email_SMS_SettingFindFirstArgs extends Admin_Email_SMS_SettingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin_Email_SMS_Setting findMany
   */
  export type Admin_Email_SMS_SettingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * Filter, which Admin_Email_SMS_Settings to fetch.
     * 
    **/
    where?: Admin_Email_SMS_SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admin_Email_SMS_Settings to fetch.
     * 
    **/
    orderBy?: Enumerable<Admin_Email_SMS_SettingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admin_Email_SMS_Settings.
     * 
    **/
    cursor?: Admin_Email_SMS_SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admin_Email_SMS_Settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admin_Email_SMS_Settings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_Email_SMS_SettingScalarFieldEnum>
  }


  /**
   * Admin_Email_SMS_Setting create
   */
  export type Admin_Email_SMS_SettingCreateArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * The data needed to create a Admin_Email_SMS_Setting.
     * 
    **/
    data?: XOR<Admin_Email_SMS_SettingCreateInput, Admin_Email_SMS_SettingUncheckedCreateInput>
  }


  /**
   * Admin_Email_SMS_Setting createMany
   */
  export type Admin_Email_SMS_SettingCreateManyArgs = {
    /**
     * The data used to create many Admin_Email_SMS_Settings.
     * 
    **/
    data: Enumerable<Admin_Email_SMS_SettingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin_Email_SMS_Setting update
   */
  export type Admin_Email_SMS_SettingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * The data needed to update a Admin_Email_SMS_Setting.
     * 
    **/
    data: XOR<Admin_Email_SMS_SettingUpdateInput, Admin_Email_SMS_SettingUncheckedUpdateInput>
    /**
     * Choose, which Admin_Email_SMS_Setting to update.
     * 
    **/
    where: Admin_Email_SMS_SettingWhereUniqueInput
  }


  /**
   * Admin_Email_SMS_Setting updateMany
   */
  export type Admin_Email_SMS_SettingUpdateManyArgs = {
    /**
     * The data used to update Admin_Email_SMS_Settings.
     * 
    **/
    data: XOR<Admin_Email_SMS_SettingUpdateManyMutationInput, Admin_Email_SMS_SettingUncheckedUpdateManyInput>
    /**
     * Filter which Admin_Email_SMS_Settings to update
     * 
    **/
    where?: Admin_Email_SMS_SettingWhereInput
  }


  /**
   * Admin_Email_SMS_Setting upsert
   */
  export type Admin_Email_SMS_SettingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * The filter to search for the Admin_Email_SMS_Setting to update in case it exists.
     * 
    **/
    where: Admin_Email_SMS_SettingWhereUniqueInput
    /**
     * In case the Admin_Email_SMS_Setting found by the `where` argument doesn't exist, create a new Admin_Email_SMS_Setting with this data.
     * 
    **/
    create: XOR<Admin_Email_SMS_SettingCreateInput, Admin_Email_SMS_SettingUncheckedCreateInput>
    /**
     * In case the Admin_Email_SMS_Setting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Admin_Email_SMS_SettingUpdateInput, Admin_Email_SMS_SettingUncheckedUpdateInput>
  }


  /**
   * Admin_Email_SMS_Setting delete
   */
  export type Admin_Email_SMS_SettingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
    /**
     * Filter which Admin_Email_SMS_Setting to delete.
     * 
    **/
    where: Admin_Email_SMS_SettingWhereUniqueInput
  }


  /**
   * Admin_Email_SMS_Setting deleteMany
   */
  export type Admin_Email_SMS_SettingDeleteManyArgs = {
    /**
     * Filter which Admin_Email_SMS_Settings to delete
     * 
    **/
    where?: Admin_Email_SMS_SettingWhereInput
  }


  /**
   * Admin_Email_SMS_Setting: findUniqueOrThrow
   */
  export type Admin_Email_SMS_SettingFindUniqueOrThrowArgs = Admin_Email_SMS_SettingFindUniqueArgsBase
      

  /**
   * Admin_Email_SMS_Setting: findFirstOrThrow
   */
  export type Admin_Email_SMS_SettingFindFirstOrThrowArgs = Admin_Email_SMS_SettingFindFirstArgsBase
      

  /**
   * Admin_Email_SMS_Setting without action
   */
  export type Admin_Email_SMS_SettingArgs = {
    /**
     * Select specific fields to fetch from the Admin_Email_SMS_Setting
     * 
    **/
    select?: Admin_Email_SMS_SettingSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Admin_Email_SMS_SettingScalarFieldEnum: {
    id: 'id'
  };

  export type Admin_Email_SMS_SettingScalarFieldEnum = (typeof Admin_Email_SMS_SettingScalarFieldEnum)[keyof typeof Admin_Email_SMS_SettingScalarFieldEnum]


  export const Admin_Main_SettingScalarFieldEnum: {
    id: 'id',
    system_name: 'system_name',
    backgroundColor: 'backgroundColor',
    fontColor: 'fontColor',
    alertFormat: 'alertFormat',
    state_to_import_wheather_alert: 'state_to_import_wheather_alert',
    logo: 'logo',
    domain: 'domain',
    CAD_URL: 'CAD_URL',
    private_system: 'private_system',
    guest_not_allowed_to_chat: 'guest_not_allowed_to_chat',
    theme: 'theme',
    fontSize: 'fontSize',
    traineeAlertColor: 'traineeAlertColor'
  };

  export type Admin_Main_SettingScalarFieldEnum = (typeof Admin_Main_SettingScalarFieldEnum)[keyof typeof Admin_Main_SettingScalarFieldEnum]


  export const Chat_MessagesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    Message: 'Message',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type Chat_MessagesScalarFieldEnum = (typeof Chat_MessagesScalarFieldEnum)[keyof typeof Chat_MessagesScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    Co_Credit: 'Co_Credit',
    Country: 'Country',
    Time: 'Time',
    Type: 'Type',
    Street: 'Street',
    City: 'City',
    State: 'State',
    Longitude: 'Longitude',
    Latitude: 'Latitude',
    Zipcode: 'Zipcode',
    Text: 'Text',
    SMS_Chr_Count: 'SMS_Chr_Count',
    Internal_Note: 'Internal_Note',
    Confirmed_Incident: 'Confirmed_Incident',
    Queue: 'Queue',
    userId: 'userId'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ResidenceScalarFieldEnum: {
    id: 'id',
    city: 'city',
    address: 'address',
    state: 'state',
    ZipCode: 'ZipCode',
    DateOfBirth: 'DateOfBirth',
    Occupation: 'Occupation',
    userId: 'userId'
  };

  export type ResidenceScalarFieldEnum = (typeof ResidenceScalarFieldEnum)[keyof typeof ResidenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_ProfileScalarFieldEnum: {
    id: 'id',
    realName: 'realName',
    phoneNo: 'phoneNo',
    carrier: 'carrier',
    alertType: 'alertType',
    pagerEmail: 'pagerEmail',
    notificationArea: 'notificationArea',
    notificationTypes: 'notificationTypes',
    personalInfo: 'personalInfo',
    sendToEmail: 'sendToEmail',
    sendTextNotification: 'sendTextNotification',
    sendToPager: 'sendToPager',
    userId: 'userId'
  };

  export type User_ProfileScalarFieldEnum = (typeof User_ProfileScalarFieldEnum)[keyof typeof User_ProfileScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    role?: StringFilter | string
    User_Profile?: User_ProfileListRelationFilter
    Residence?: ResidenceListRelationFilter
    Chat_Messages?: Chat_MessagesListRelationFilter
    Incident?: IncidentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    User_Profile?: User_ProfileOrderByRelationAggregateInput
    Residence?: ResidenceOrderByRelationAggregateInput
    Chat_Messages?: Chat_MessagesOrderByRelationAggregateInput
    Incident?: IncidentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
  }

  export type User_ProfileWhereInput = {
    AND?: Enumerable<User_ProfileWhereInput>
    OR?: Enumerable<User_ProfileWhereInput>
    NOT?: Enumerable<User_ProfileWhereInput>
    id?: IntFilter | number
    realName?: StringFilter | string
    phoneNo?: IntFilter | number
    carrier?: StringFilter | string
    alertType?: StringFilter | string
    pagerEmail?: StringFilter | string
    notificationArea?: StringFilter | string
    notificationTypes?: StringNullableListFilter
    personalInfo?: StringFilter | string
    sendToEmail?: BoolFilter | boolean
    sendTextNotification?: BoolFilter | boolean
    sendToPager?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
  }

  export type User_ProfileOrderByWithRelationInput = {
    id?: SortOrder
    realName?: SortOrder
    phoneNo?: SortOrder
    carrier?: SortOrder
    alertType?: SortOrder
    pagerEmail?: SortOrder
    notificationArea?: SortOrder
    notificationTypes?: SortOrder
    personalInfo?: SortOrder
    sendToEmail?: SortOrder
    sendTextNotification?: SortOrder
    sendToPager?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type User_ProfileWhereUniqueInput = {
    id?: number
  }

  export type User_ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    realName?: SortOrder
    phoneNo?: SortOrder
    carrier?: SortOrder
    alertType?: SortOrder
    pagerEmail?: SortOrder
    notificationArea?: SortOrder
    notificationTypes?: SortOrder
    personalInfo?: SortOrder
    sendToEmail?: SortOrder
    sendTextNotification?: SortOrder
    sendToPager?: SortOrder
    userId?: SortOrder
    _count?: User_ProfileCountOrderByAggregateInput
    _avg?: User_ProfileAvgOrderByAggregateInput
    _max?: User_ProfileMaxOrderByAggregateInput
    _min?: User_ProfileMinOrderByAggregateInput
    _sum?: User_ProfileSumOrderByAggregateInput
  }

  export type User_ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<User_ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<User_ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<User_ProfileScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    realName?: StringWithAggregatesFilter | string
    phoneNo?: IntWithAggregatesFilter | number
    carrier?: StringWithAggregatesFilter | string
    alertType?: StringWithAggregatesFilter | string
    pagerEmail?: StringWithAggregatesFilter | string
    notificationArea?: StringWithAggregatesFilter | string
    notificationTypes?: StringNullableListFilter
    personalInfo?: StringWithAggregatesFilter | string
    sendToEmail?: BoolWithAggregatesFilter | boolean
    sendTextNotification?: BoolWithAggregatesFilter | boolean
    sendToPager?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
  }

  export type ResidenceWhereInput = {
    AND?: Enumerable<ResidenceWhereInput>
    OR?: Enumerable<ResidenceWhereInput>
    NOT?: Enumerable<ResidenceWhereInput>
    id?: IntFilter | number
    city?: StringFilter | string
    address?: StringFilter | string
    state?: StringFilter | string
    ZipCode?: IntFilter | number
    DateOfBirth?: DateTimeFilter | Date | string
    Occupation?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
  }

  export type ResidenceOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrder
    address?: SortOrder
    state?: SortOrder
    ZipCode?: SortOrder
    DateOfBirth?: SortOrder
    Occupation?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type ResidenceWhereUniqueInput = {
    id?: number
  }

  export type ResidenceOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrder
    address?: SortOrder
    state?: SortOrder
    ZipCode?: SortOrder
    DateOfBirth?: SortOrder
    Occupation?: SortOrder
    userId?: SortOrder
    _count?: ResidenceCountOrderByAggregateInput
    _avg?: ResidenceAvgOrderByAggregateInput
    _max?: ResidenceMaxOrderByAggregateInput
    _min?: ResidenceMinOrderByAggregateInput
    _sum?: ResidenceSumOrderByAggregateInput
  }

  export type ResidenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResidenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResidenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResidenceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    city?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    ZipCode?: IntWithAggregatesFilter | number
    DateOfBirth?: DateTimeWithAggregatesFilter | Date | string
    Occupation?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type IncidentWhereInput = {
    AND?: Enumerable<IncidentWhereInput>
    OR?: Enumerable<IncidentWhereInput>
    NOT?: Enumerable<IncidentWhereInput>
    id?: IntFilter | number
    Co_Credit?: StringFilter | string
    Country?: StringFilter | string
    Time?: DateTimeFilter | Date | string
    Type?: StringFilter | string
    Street?: StringFilter | string
    City?: StringFilter | string
    State?: StringFilter | string
    Longitude?: FloatFilter | number
    Latitude?: FloatFilter | number
    Zipcode?: IntFilter | number
    Text?: StringFilter | string
    SMS_Chr_Count?: IntFilter | number
    Internal_Note?: StringFilter | string
    Confirmed_Incident?: BoolFilter | boolean
    Queue?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    Co_Credit?: SortOrder
    Country?: SortOrder
    Time?: SortOrder
    Type?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    Text?: SortOrder
    SMS_Chr_Count?: SortOrder
    Internal_Note?: SortOrder
    Confirmed_Incident?: SortOrder
    Queue?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type IncidentWhereUniqueInput = {
    id?: number
  }

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    Co_Credit?: SortOrder
    Country?: SortOrder
    Time?: SortOrder
    Type?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    Text?: SortOrder
    SMS_Chr_Count?: SortOrder
    Internal_Note?: SortOrder
    Confirmed_Incident?: SortOrder
    Queue?: SortOrder
    userId?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _avg?: IncidentAvgOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
    _sum?: IncidentSumOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncidentScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncidentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncidentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    Co_Credit?: StringWithAggregatesFilter | string
    Country?: StringWithAggregatesFilter | string
    Time?: DateTimeWithAggregatesFilter | Date | string
    Type?: StringWithAggregatesFilter | string
    Street?: StringWithAggregatesFilter | string
    City?: StringWithAggregatesFilter | string
    State?: StringWithAggregatesFilter | string
    Longitude?: FloatWithAggregatesFilter | number
    Latitude?: FloatWithAggregatesFilter | number
    Zipcode?: IntWithAggregatesFilter | number
    Text?: StringWithAggregatesFilter | string
    SMS_Chr_Count?: IntWithAggregatesFilter | number
    Internal_Note?: StringWithAggregatesFilter | string
    Confirmed_Incident?: BoolWithAggregatesFilter | boolean
    Queue?: BoolWithAggregatesFilter | boolean
    userId?: IntWithAggregatesFilter | number
  }

  export type Chat_MessagesWhereInput = {
    AND?: Enumerable<Chat_MessagesWhereInput>
    OR?: Enumerable<Chat_MessagesWhereInput>
    NOT?: Enumerable<Chat_MessagesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    Message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
  }

  export type Chat_MessagesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Message?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
  }

  export type Chat_MessagesWhereUniqueInput = {
    id?: number
  }

  export type Chat_MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    Message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: Chat_MessagesCountOrderByAggregateInput
    _avg?: Chat_MessagesAvgOrderByAggregateInput
    _max?: Chat_MessagesMaxOrderByAggregateInput
    _min?: Chat_MessagesMinOrderByAggregateInput
    _sum?: Chat_MessagesSumOrderByAggregateInput
  }

  export type Chat_MessagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Chat_MessagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<Chat_MessagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Chat_MessagesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    Message?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
  }

  export type Admin_Main_SettingWhereInput = {
    AND?: Enumerable<Admin_Main_SettingWhereInput>
    OR?: Enumerable<Admin_Main_SettingWhereInput>
    NOT?: Enumerable<Admin_Main_SettingWhereInput>
    id?: IntFilter | number
    system_name?: StringFilter | string
    backgroundColor?: StringFilter | string
    fontColor?: StringFilter | string
    alertFormat?: StringFilter | string
    state_to_import_wheather_alert?: StringFilter | string
    logo?: BytesFilter | Buffer
    domain?: StringFilter | string
    CAD_URL?: StringFilter | string
    private_system?: BoolFilter | boolean
    guest_not_allowed_to_chat?: BoolFilter | boolean
    theme?: StringFilter | string
    fontSize?: StringFilter | string
    traineeAlertColor?: StringFilter | string
  }

  export type Admin_Main_SettingOrderByWithRelationInput = {
    id?: SortOrder
    system_name?: SortOrder
    backgroundColor?: SortOrder
    fontColor?: SortOrder
    alertFormat?: SortOrder
    state_to_import_wheather_alert?: SortOrder
    logo?: SortOrder
    domain?: SortOrder
    CAD_URL?: SortOrder
    private_system?: SortOrder
    guest_not_allowed_to_chat?: SortOrder
    theme?: SortOrder
    fontSize?: SortOrder
    traineeAlertColor?: SortOrder
  }

  export type Admin_Main_SettingWhereUniqueInput = {
    id?: number
  }

  export type Admin_Main_SettingOrderByWithAggregationInput = {
    id?: SortOrder
    system_name?: SortOrder
    backgroundColor?: SortOrder
    fontColor?: SortOrder
    alertFormat?: SortOrder
    state_to_import_wheather_alert?: SortOrder
    logo?: SortOrder
    domain?: SortOrder
    CAD_URL?: SortOrder
    private_system?: SortOrder
    guest_not_allowed_to_chat?: SortOrder
    theme?: SortOrder
    fontSize?: SortOrder
    traineeAlertColor?: SortOrder
    _count?: Admin_Main_SettingCountOrderByAggregateInput
    _avg?: Admin_Main_SettingAvgOrderByAggregateInput
    _max?: Admin_Main_SettingMaxOrderByAggregateInput
    _min?: Admin_Main_SettingMinOrderByAggregateInput
    _sum?: Admin_Main_SettingSumOrderByAggregateInput
  }

  export type Admin_Main_SettingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Admin_Main_SettingScalarWhereWithAggregatesInput>
    OR?: Enumerable<Admin_Main_SettingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Admin_Main_SettingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    system_name?: StringWithAggregatesFilter | string
    backgroundColor?: StringWithAggregatesFilter | string
    fontColor?: StringWithAggregatesFilter | string
    alertFormat?: StringWithAggregatesFilter | string
    state_to_import_wheather_alert?: StringWithAggregatesFilter | string
    logo?: BytesWithAggregatesFilter | Buffer
    domain?: StringWithAggregatesFilter | string
    CAD_URL?: StringWithAggregatesFilter | string
    private_system?: BoolWithAggregatesFilter | boolean
    guest_not_allowed_to_chat?: BoolWithAggregatesFilter | boolean
    theme?: StringWithAggregatesFilter | string
    fontSize?: StringWithAggregatesFilter | string
    traineeAlertColor?: StringWithAggregatesFilter | string
  }

  export type Admin_Email_SMS_SettingWhereInput = {
    AND?: Enumerable<Admin_Email_SMS_SettingWhereInput>
    OR?: Enumerable<Admin_Email_SMS_SettingWhereInput>
    NOT?: Enumerable<Admin_Email_SMS_SettingWhereInput>
    id?: IntFilter | number
  }

  export type Admin_Email_SMS_SettingOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type Admin_Email_SMS_SettingWhereUniqueInput = {
    id?: number
  }

  export type Admin_Email_SMS_SettingOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: Admin_Email_SMS_SettingCountOrderByAggregateInput
    _avg?: Admin_Email_SMS_SettingAvgOrderByAggregateInput
    _max?: Admin_Email_SMS_SettingMaxOrderByAggregateInput
    _min?: Admin_Email_SMS_SettingMinOrderByAggregateInput
    _sum?: Admin_Email_SMS_SettingSumOrderByAggregateInput
  }

  export type Admin_Email_SMS_SettingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Admin_Email_SMS_SettingScalarWhereWithAggregatesInput>
    OR?: Enumerable<Admin_Email_SMS_SettingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Admin_Email_SMS_SettingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileCreateNestedManyWithoutUserInput
    Residence?: ResidenceCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesCreateNestedManyWithoutUserInput
    Incident?: IncidentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileUncheckedCreateNestedManyWithoutUserInput
    Residence?: ResidenceUncheckedCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesUncheckedCreateNestedManyWithoutUserInput
    Incident?: IncidentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUpdateManyWithoutUserNestedInput
    Incident?: IncidentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUncheckedUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUncheckedUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUncheckedUpdateManyWithoutUserNestedInput
    Incident?: IncidentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type User_ProfileCreateInput = {
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
    user: UserCreateNestedOneWithoutUser_ProfileInput
  }

  export type User_ProfileUncheckedCreateInput = {
    id?: number
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
    userId: number
  }

  export type User_ProfileUpdateInput = {
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUser_ProfileNestedInput
  }

  export type User_ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type User_ProfileCreateManyInput = {
    id?: number
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
    userId: number
  }

  export type User_ProfileUpdateManyMutationInput = {
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ResidenceCreateInput = {
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
    user: UserCreateNestedOneWithoutResidenceInput
  }

  export type ResidenceUncheckedCreateInput = {
    id?: number
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
    userId: number
  }

  export type ResidenceUpdateInput = {
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutResidenceNestedInput
  }

  export type ResidenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ResidenceCreateManyInput = {
    id?: number
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
    userId: number
  }

  export type ResidenceUpdateManyMutationInput = {
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IncidentCreateInput = {
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
    user: UserCreateNestedOneWithoutIncidentInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: number
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
    userId: number
  }

  export type IncidentUpdateInput = {
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutIncidentNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type IncidentCreateManyInput = {
    id?: number
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
    userId: number
  }

  export type IncidentUpdateManyMutationInput = {
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Chat_MessagesCreateInput = {
    name: string
    Message: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChat_MessagesInput
  }

  export type Chat_MessagesUncheckedCreateInput = {
    id?: number
    name: string
    Message: string
    createdAt?: Date | string
    userId: number
  }

  export type Chat_MessagesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChat_MessagesNestedInput
  }

  export type Chat_MessagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Chat_MessagesCreateManyInput = {
    id?: number
    name: string
    Message: string
    createdAt?: Date | string
    userId: number
  }

  export type Chat_MessagesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Chat_MessagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type Admin_Main_SettingCreateInput = {
    system_name?: string
    backgroundColor?: string
    fontColor?: string
    alertFormat: string
    state_to_import_wheather_alert?: string
    logo: Buffer
    domain?: string
    CAD_URL?: string
    private_system?: boolean
    guest_not_allowed_to_chat?: boolean
    theme?: string
    fontSize?: string
    traineeAlertColor?: string
  }

  export type Admin_Main_SettingUncheckedCreateInput = {
    id?: number
    system_name?: string
    backgroundColor?: string
    fontColor?: string
    alertFormat: string
    state_to_import_wheather_alert?: string
    logo: Buffer
    domain?: string
    CAD_URL?: string
    private_system?: boolean
    guest_not_allowed_to_chat?: boolean
    theme?: string
    fontSize?: string
    traineeAlertColor?: string
  }

  export type Admin_Main_SettingUpdateInput = {
    system_name?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    fontColor?: StringFieldUpdateOperationsInput | string
    alertFormat?: StringFieldUpdateOperationsInput | string
    state_to_import_wheather_alert?: StringFieldUpdateOperationsInput | string
    logo?: BytesFieldUpdateOperationsInput | Buffer
    domain?: StringFieldUpdateOperationsInput | string
    CAD_URL?: StringFieldUpdateOperationsInput | string
    private_system?: BoolFieldUpdateOperationsInput | boolean
    guest_not_allowed_to_chat?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    fontSize?: StringFieldUpdateOperationsInput | string
    traineeAlertColor?: StringFieldUpdateOperationsInput | string
  }

  export type Admin_Main_SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    system_name?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    fontColor?: StringFieldUpdateOperationsInput | string
    alertFormat?: StringFieldUpdateOperationsInput | string
    state_to_import_wheather_alert?: StringFieldUpdateOperationsInput | string
    logo?: BytesFieldUpdateOperationsInput | Buffer
    domain?: StringFieldUpdateOperationsInput | string
    CAD_URL?: StringFieldUpdateOperationsInput | string
    private_system?: BoolFieldUpdateOperationsInput | boolean
    guest_not_allowed_to_chat?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    fontSize?: StringFieldUpdateOperationsInput | string
    traineeAlertColor?: StringFieldUpdateOperationsInput | string
  }

  export type Admin_Main_SettingCreateManyInput = {
    id?: number
    system_name?: string
    backgroundColor?: string
    fontColor?: string
    alertFormat: string
    state_to_import_wheather_alert?: string
    logo: Buffer
    domain?: string
    CAD_URL?: string
    private_system?: boolean
    guest_not_allowed_to_chat?: boolean
    theme?: string
    fontSize?: string
    traineeAlertColor?: string
  }

  export type Admin_Main_SettingUpdateManyMutationInput = {
    system_name?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    fontColor?: StringFieldUpdateOperationsInput | string
    alertFormat?: StringFieldUpdateOperationsInput | string
    state_to_import_wheather_alert?: StringFieldUpdateOperationsInput | string
    logo?: BytesFieldUpdateOperationsInput | Buffer
    domain?: StringFieldUpdateOperationsInput | string
    CAD_URL?: StringFieldUpdateOperationsInput | string
    private_system?: BoolFieldUpdateOperationsInput | boolean
    guest_not_allowed_to_chat?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    fontSize?: StringFieldUpdateOperationsInput | string
    traineeAlertColor?: StringFieldUpdateOperationsInput | string
  }

  export type Admin_Main_SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    system_name?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    fontColor?: StringFieldUpdateOperationsInput | string
    alertFormat?: StringFieldUpdateOperationsInput | string
    state_to_import_wheather_alert?: StringFieldUpdateOperationsInput | string
    logo?: BytesFieldUpdateOperationsInput | Buffer
    domain?: StringFieldUpdateOperationsInput | string
    CAD_URL?: StringFieldUpdateOperationsInput | string
    private_system?: BoolFieldUpdateOperationsInput | boolean
    guest_not_allowed_to_chat?: BoolFieldUpdateOperationsInput | boolean
    theme?: StringFieldUpdateOperationsInput | string
    fontSize?: StringFieldUpdateOperationsInput | string
    traineeAlertColor?: StringFieldUpdateOperationsInput | string
  }

  export type Admin_Email_SMS_SettingCreateInput = {

  }

  export type Admin_Email_SMS_SettingUncheckedCreateInput = {
    id?: number
  }

  export type Admin_Email_SMS_SettingUpdateInput = {

  }

  export type Admin_Email_SMS_SettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type Admin_Email_SMS_SettingCreateManyInput = {
    id?: number
  }

  export type Admin_Email_SMS_SettingUpdateManyMutationInput = {

  }

  export type Admin_Email_SMS_SettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type User_ProfileListRelationFilter = {
    every?: User_ProfileWhereInput
    some?: User_ProfileWhereInput
    none?: User_ProfileWhereInput
  }

  export type ResidenceListRelationFilter = {
    every?: ResidenceWhereInput
    some?: ResidenceWhereInput
    none?: ResidenceWhereInput
  }

  export type Chat_MessagesListRelationFilter = {
    every?: Chat_MessagesWhereInput
    some?: Chat_MessagesWhereInput
    none?: Chat_MessagesWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type User_ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Chat_MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type User_ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    realName?: SortOrder
    phoneNo?: SortOrder
    carrier?: SortOrder
    alertType?: SortOrder
    pagerEmail?: SortOrder
    notificationArea?: SortOrder
    notificationTypes?: SortOrder
    personalInfo?: SortOrder
    sendToEmail?: SortOrder
    sendTextNotification?: SortOrder
    sendToPager?: SortOrder
    userId?: SortOrder
  }

  export type User_ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    phoneNo?: SortOrder
    userId?: SortOrder
  }

  export type User_ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    realName?: SortOrder
    phoneNo?: SortOrder
    carrier?: SortOrder
    alertType?: SortOrder
    pagerEmail?: SortOrder
    notificationArea?: SortOrder
    personalInfo?: SortOrder
    sendToEmail?: SortOrder
    sendTextNotification?: SortOrder
    sendToPager?: SortOrder
    userId?: SortOrder
  }

  export type User_ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    realName?: SortOrder
    phoneNo?: SortOrder
    carrier?: SortOrder
    alertType?: SortOrder
    pagerEmail?: SortOrder
    notificationArea?: SortOrder
    personalInfo?: SortOrder
    sendToEmail?: SortOrder
    sendTextNotification?: SortOrder
    sendToPager?: SortOrder
    userId?: SortOrder
  }

  export type User_ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    phoneNo?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ResidenceCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    address?: SortOrder
    state?: SortOrder
    ZipCode?: SortOrder
    DateOfBirth?: SortOrder
    Occupation?: SortOrder
    userId?: SortOrder
  }

  export type ResidenceAvgOrderByAggregateInput = {
    id?: SortOrder
    ZipCode?: SortOrder
    userId?: SortOrder
  }

  export type ResidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    address?: SortOrder
    state?: SortOrder
    ZipCode?: SortOrder
    DateOfBirth?: SortOrder
    Occupation?: SortOrder
    userId?: SortOrder
  }

  export type ResidenceMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    address?: SortOrder
    state?: SortOrder
    ZipCode?: SortOrder
    DateOfBirth?: SortOrder
    Occupation?: SortOrder
    userId?: SortOrder
  }

  export type ResidenceSumOrderByAggregateInput = {
    id?: SortOrder
    ZipCode?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    Co_Credit?: SortOrder
    Country?: SortOrder
    Time?: SortOrder
    Type?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    Text?: SortOrder
    SMS_Chr_Count?: SortOrder
    Internal_Note?: SortOrder
    Confirmed_Incident?: SortOrder
    Queue?: SortOrder
    userId?: SortOrder
  }

  export type IncidentAvgOrderByAggregateInput = {
    id?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    SMS_Chr_Count?: SortOrder
    userId?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    Co_Credit?: SortOrder
    Country?: SortOrder
    Time?: SortOrder
    Type?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    Text?: SortOrder
    SMS_Chr_Count?: SortOrder
    Internal_Note?: SortOrder
    Confirmed_Incident?: SortOrder
    Queue?: SortOrder
    userId?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    Co_Credit?: SortOrder
    Country?: SortOrder
    Time?: SortOrder
    Type?: SortOrder
    Street?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    Text?: SortOrder
    SMS_Chr_Count?: SortOrder
    Internal_Note?: SortOrder
    Confirmed_Incident?: SortOrder
    Queue?: SortOrder
    userId?: SortOrder
  }

  export type IncidentSumOrderByAggregateInput = {
    id?: SortOrder
    Longitude?: SortOrder
    Latitude?: SortOrder
    Zipcode?: SortOrder
    SMS_Chr_Count?: SortOrder
    userId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type Chat_MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type Chat_MessagesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Chat_MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type Chat_MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    Message?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type Chat_MessagesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type Admin_Main_SettingCountOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    backgroundColor?: SortOrder
    fontColor?: SortOrder
    alertFormat?: SortOrder
    state_to_import_wheather_alert?: SortOrder
    logo?: SortOrder
    domain?: SortOrder
    CAD_URL?: SortOrder
    private_system?: SortOrder
    guest_not_allowed_to_chat?: SortOrder
    theme?: SortOrder
    fontSize?: SortOrder
    traineeAlertColor?: SortOrder
  }

  export type Admin_Main_SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_Main_SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    backgroundColor?: SortOrder
    fontColor?: SortOrder
    alertFormat?: SortOrder
    state_to_import_wheather_alert?: SortOrder
    logo?: SortOrder
    domain?: SortOrder
    CAD_URL?: SortOrder
    private_system?: SortOrder
    guest_not_allowed_to_chat?: SortOrder
    theme?: SortOrder
    fontSize?: SortOrder
    traineeAlertColor?: SortOrder
  }

  export type Admin_Main_SettingMinOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    backgroundColor?: SortOrder
    fontColor?: SortOrder
    alertFormat?: SortOrder
    state_to_import_wheather_alert?: SortOrder
    logo?: SortOrder
    domain?: SortOrder
    CAD_URL?: SortOrder
    private_system?: SortOrder
    guest_not_allowed_to_chat?: SortOrder
    theme?: SortOrder
    fontSize?: SortOrder
    traineeAlertColor?: SortOrder
  }

  export type Admin_Main_SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type Admin_Email_SMS_SettingCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_Email_SMS_SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_Email_SMS_SettingMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_Email_SMS_SettingMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_Email_SMS_SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type User_ProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_ProfileCreateWithoutUserInput>, Enumerable<User_ProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_ProfileCreateOrConnectWithoutUserInput>
    createMany?: User_ProfileCreateManyUserInputEnvelope
    connect?: Enumerable<User_ProfileWhereUniqueInput>
  }

  export type ResidenceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResidenceCreateWithoutUserInput>, Enumerable<ResidenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResidenceCreateOrConnectWithoutUserInput>
    createMany?: ResidenceCreateManyUserInputEnvelope
    connect?: Enumerable<ResidenceWhereUniqueInput>
  }

  export type Chat_MessagesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Chat_MessagesCreateWithoutUserInput>, Enumerable<Chat_MessagesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Chat_MessagesCreateOrConnectWithoutUserInput>
    createMany?: Chat_MessagesCreateManyUserInputEnvelope
    connect?: Enumerable<Chat_MessagesWhereUniqueInput>
  }

  export type IncidentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IncidentCreateWithoutUserInput>, Enumerable<IncidentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IncidentCreateOrConnectWithoutUserInput>
    createMany?: IncidentCreateManyUserInputEnvelope
    connect?: Enumerable<IncidentWhereUniqueInput>
  }

  export type User_ProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_ProfileCreateWithoutUserInput>, Enumerable<User_ProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_ProfileCreateOrConnectWithoutUserInput>
    createMany?: User_ProfileCreateManyUserInputEnvelope
    connect?: Enumerable<User_ProfileWhereUniqueInput>
  }

  export type ResidenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ResidenceCreateWithoutUserInput>, Enumerable<ResidenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResidenceCreateOrConnectWithoutUserInput>
    createMany?: ResidenceCreateManyUserInputEnvelope
    connect?: Enumerable<ResidenceWhereUniqueInput>
  }

  export type Chat_MessagesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<Chat_MessagesCreateWithoutUserInput>, Enumerable<Chat_MessagesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Chat_MessagesCreateOrConnectWithoutUserInput>
    createMany?: Chat_MessagesCreateManyUserInputEnvelope
    connect?: Enumerable<Chat_MessagesWhereUniqueInput>
  }

  export type IncidentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<IncidentCreateWithoutUserInput>, Enumerable<IncidentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IncidentCreateOrConnectWithoutUserInput>
    createMany?: IncidentCreateManyUserInputEnvelope
    connect?: Enumerable<IncidentWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type User_ProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<User_ProfileCreateWithoutUserInput>, Enumerable<User_ProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_ProfileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_ProfileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_ProfileCreateManyUserInputEnvelope
    set?: Enumerable<User_ProfileWhereUniqueInput>
    disconnect?: Enumerable<User_ProfileWhereUniqueInput>
    delete?: Enumerable<User_ProfileWhereUniqueInput>
    connect?: Enumerable<User_ProfileWhereUniqueInput>
    update?: Enumerable<User_ProfileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_ProfileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_ProfileScalarWhereInput>
  }

  export type ResidenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResidenceCreateWithoutUserInput>, Enumerable<ResidenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResidenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResidenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResidenceCreateManyUserInputEnvelope
    set?: Enumerable<ResidenceWhereUniqueInput>
    disconnect?: Enumerable<ResidenceWhereUniqueInput>
    delete?: Enumerable<ResidenceWhereUniqueInput>
    connect?: Enumerable<ResidenceWhereUniqueInput>
    update?: Enumerable<ResidenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResidenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResidenceScalarWhereInput>
  }

  export type Chat_MessagesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Chat_MessagesCreateWithoutUserInput>, Enumerable<Chat_MessagesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Chat_MessagesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Chat_MessagesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Chat_MessagesCreateManyUserInputEnvelope
    set?: Enumerable<Chat_MessagesWhereUniqueInput>
    disconnect?: Enumerable<Chat_MessagesWhereUniqueInput>
    delete?: Enumerable<Chat_MessagesWhereUniqueInput>
    connect?: Enumerable<Chat_MessagesWhereUniqueInput>
    update?: Enumerable<Chat_MessagesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Chat_MessagesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Chat_MessagesScalarWhereInput>
  }

  export type IncidentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IncidentCreateWithoutUserInput>, Enumerable<IncidentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IncidentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IncidentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IncidentCreateManyUserInputEnvelope
    set?: Enumerable<IncidentWhereUniqueInput>
    disconnect?: Enumerable<IncidentWhereUniqueInput>
    delete?: Enumerable<IncidentWhereUniqueInput>
    connect?: Enumerable<IncidentWhereUniqueInput>
    update?: Enumerable<IncidentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IncidentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IncidentScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type User_ProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<User_ProfileCreateWithoutUserInput>, Enumerable<User_ProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_ProfileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_ProfileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_ProfileCreateManyUserInputEnvelope
    set?: Enumerable<User_ProfileWhereUniqueInput>
    disconnect?: Enumerable<User_ProfileWhereUniqueInput>
    delete?: Enumerable<User_ProfileWhereUniqueInput>
    connect?: Enumerable<User_ProfileWhereUniqueInput>
    update?: Enumerable<User_ProfileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_ProfileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_ProfileScalarWhereInput>
  }

  export type ResidenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ResidenceCreateWithoutUserInput>, Enumerable<ResidenceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ResidenceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ResidenceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ResidenceCreateManyUserInputEnvelope
    set?: Enumerable<ResidenceWhereUniqueInput>
    disconnect?: Enumerable<ResidenceWhereUniqueInput>
    delete?: Enumerable<ResidenceWhereUniqueInput>
    connect?: Enumerable<ResidenceWhereUniqueInput>
    update?: Enumerable<ResidenceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ResidenceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ResidenceScalarWhereInput>
  }

  export type Chat_MessagesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<Chat_MessagesCreateWithoutUserInput>, Enumerable<Chat_MessagesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<Chat_MessagesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<Chat_MessagesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: Chat_MessagesCreateManyUserInputEnvelope
    set?: Enumerable<Chat_MessagesWhereUniqueInput>
    disconnect?: Enumerable<Chat_MessagesWhereUniqueInput>
    delete?: Enumerable<Chat_MessagesWhereUniqueInput>
    connect?: Enumerable<Chat_MessagesWhereUniqueInput>
    update?: Enumerable<Chat_MessagesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<Chat_MessagesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<Chat_MessagesScalarWhereInput>
  }

  export type IncidentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<IncidentCreateWithoutUserInput>, Enumerable<IncidentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<IncidentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<IncidentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: IncidentCreateManyUserInputEnvelope
    set?: Enumerable<IncidentWhereUniqueInput>
    disconnect?: Enumerable<IncidentWhereUniqueInput>
    delete?: Enumerable<IncidentWhereUniqueInput>
    connect?: Enumerable<IncidentWhereUniqueInput>
    update?: Enumerable<IncidentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<IncidentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<IncidentScalarWhereInput>
  }

  export type User_ProfileCreatenotificationTypesInput = {
    set: Enumerable<string>
  }

  export type UserCreateNestedOneWithoutUser_ProfileInput = {
    create?: XOR<UserCreateWithoutUser_ProfileInput, UserUncheckedCreateWithoutUser_ProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_ProfileInput
    connect?: UserWhereUniqueInput
  }

  export type User_ProfileUpdatenotificationTypesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutUser_ProfileNestedInput = {
    create?: XOR<UserCreateWithoutUser_ProfileInput, UserUncheckedCreateWithoutUser_ProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_ProfileInput
    upsert?: UserUpsertWithoutUser_ProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_ProfileInput, UserUncheckedUpdateWithoutUser_ProfileInput>
  }

  export type UserCreateNestedOneWithoutResidenceInput = {
    create?: XOR<UserCreateWithoutResidenceInput, UserUncheckedCreateWithoutResidenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutResidenceInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutResidenceNestedInput = {
    create?: XOR<UserCreateWithoutResidenceInput, UserUncheckedCreateWithoutResidenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutResidenceInput
    upsert?: UserUpsertWithoutResidenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutResidenceInput, UserUncheckedUpdateWithoutResidenceInput>
  }

  export type UserCreateNestedOneWithoutIncidentInput = {
    create?: XOR<UserCreateWithoutIncidentInput, UserUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncidentInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutIncidentNestedInput = {
    create?: XOR<UserCreateWithoutIncidentInput, UserUncheckedCreateWithoutIncidentInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncidentInput
    upsert?: UserUpsertWithoutIncidentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIncidentInput, UserUncheckedUpdateWithoutIncidentInput>
  }

  export type UserCreateNestedOneWithoutChat_MessagesInput = {
    create?: XOR<UserCreateWithoutChat_MessagesInput, UserUncheckedCreateWithoutChat_MessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChat_MessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChat_MessagesNestedInput = {
    create?: XOR<UserCreateWithoutChat_MessagesInput, UserUncheckedCreateWithoutChat_MessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChat_MessagesInput
    upsert?: UserUpsertWithoutChat_MessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutChat_MessagesInput, UserUncheckedUpdateWithoutChat_MessagesInput>
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type User_ProfileCreateWithoutUserInput = {
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
  }

  export type User_ProfileUncheckedCreateWithoutUserInput = {
    id?: number
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
  }

  export type User_ProfileCreateOrConnectWithoutUserInput = {
    where: User_ProfileWhereUniqueInput
    create: XOR<User_ProfileCreateWithoutUserInput, User_ProfileUncheckedCreateWithoutUserInput>
  }

  export type User_ProfileCreateManyUserInputEnvelope = {
    data: Enumerable<User_ProfileCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ResidenceCreateWithoutUserInput = {
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
  }

  export type ResidenceUncheckedCreateWithoutUserInput = {
    id?: number
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
  }

  export type ResidenceCreateOrConnectWithoutUserInput = {
    where: ResidenceWhereUniqueInput
    create: XOR<ResidenceCreateWithoutUserInput, ResidenceUncheckedCreateWithoutUserInput>
  }

  export type ResidenceCreateManyUserInputEnvelope = {
    data: Enumerable<ResidenceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type Chat_MessagesCreateWithoutUserInput = {
    name: string
    Message: string
    createdAt?: Date | string
  }

  export type Chat_MessagesUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    Message: string
    createdAt?: Date | string
  }

  export type Chat_MessagesCreateOrConnectWithoutUserInput = {
    where: Chat_MessagesWhereUniqueInput
    create: XOR<Chat_MessagesCreateWithoutUserInput, Chat_MessagesUncheckedCreateWithoutUserInput>
  }

  export type Chat_MessagesCreateManyUserInputEnvelope = {
    data: Enumerable<Chat_MessagesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutUserInput = {
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
  }

  export type IncidentUncheckedCreateWithoutUserInput = {
    id?: number
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
  }

  export type IncidentCreateOrConnectWithoutUserInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutUserInput, IncidentUncheckedCreateWithoutUserInput>
  }

  export type IncidentCreateManyUserInputEnvelope = {
    data: Enumerable<IncidentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type User_ProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: User_ProfileWhereUniqueInput
    update: XOR<User_ProfileUpdateWithoutUserInput, User_ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<User_ProfileCreateWithoutUserInput, User_ProfileUncheckedCreateWithoutUserInput>
  }

  export type User_ProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: User_ProfileWhereUniqueInput
    data: XOR<User_ProfileUpdateWithoutUserInput, User_ProfileUncheckedUpdateWithoutUserInput>
  }

  export type User_ProfileUpdateManyWithWhereWithoutUserInput = {
    where: User_ProfileScalarWhereInput
    data: XOR<User_ProfileUpdateManyMutationInput, User_ProfileUncheckedUpdateManyWithoutUser_ProfileInput>
  }

  export type User_ProfileScalarWhereInput = {
    AND?: Enumerable<User_ProfileScalarWhereInput>
    OR?: Enumerable<User_ProfileScalarWhereInput>
    NOT?: Enumerable<User_ProfileScalarWhereInput>
    id?: IntFilter | number
    realName?: StringFilter | string
    phoneNo?: IntFilter | number
    carrier?: StringFilter | string
    alertType?: StringFilter | string
    pagerEmail?: StringFilter | string
    notificationArea?: StringFilter | string
    notificationTypes?: StringNullableListFilter
    personalInfo?: StringFilter | string
    sendToEmail?: BoolFilter | boolean
    sendTextNotification?: BoolFilter | boolean
    sendToPager?: BoolFilter | boolean
    userId?: IntFilter | number
  }

  export type ResidenceUpsertWithWhereUniqueWithoutUserInput = {
    where: ResidenceWhereUniqueInput
    update: XOR<ResidenceUpdateWithoutUserInput, ResidenceUncheckedUpdateWithoutUserInput>
    create: XOR<ResidenceCreateWithoutUserInput, ResidenceUncheckedCreateWithoutUserInput>
  }

  export type ResidenceUpdateWithWhereUniqueWithoutUserInput = {
    where: ResidenceWhereUniqueInput
    data: XOR<ResidenceUpdateWithoutUserInput, ResidenceUncheckedUpdateWithoutUserInput>
  }

  export type ResidenceUpdateManyWithWhereWithoutUserInput = {
    where: ResidenceScalarWhereInput
    data: XOR<ResidenceUpdateManyMutationInput, ResidenceUncheckedUpdateManyWithoutResidenceInput>
  }

  export type ResidenceScalarWhereInput = {
    AND?: Enumerable<ResidenceScalarWhereInput>
    OR?: Enumerable<ResidenceScalarWhereInput>
    NOT?: Enumerable<ResidenceScalarWhereInput>
    id?: IntFilter | number
    city?: StringFilter | string
    address?: StringFilter | string
    state?: StringFilter | string
    ZipCode?: IntFilter | number
    DateOfBirth?: DateTimeFilter | Date | string
    Occupation?: StringFilter | string
    userId?: IntFilter | number
  }

  export type Chat_MessagesUpsertWithWhereUniqueWithoutUserInput = {
    where: Chat_MessagesWhereUniqueInput
    update: XOR<Chat_MessagesUpdateWithoutUserInput, Chat_MessagesUncheckedUpdateWithoutUserInput>
    create: XOR<Chat_MessagesCreateWithoutUserInput, Chat_MessagesUncheckedCreateWithoutUserInput>
  }

  export type Chat_MessagesUpdateWithWhereUniqueWithoutUserInput = {
    where: Chat_MessagesWhereUniqueInput
    data: XOR<Chat_MessagesUpdateWithoutUserInput, Chat_MessagesUncheckedUpdateWithoutUserInput>
  }

  export type Chat_MessagesUpdateManyWithWhereWithoutUserInput = {
    where: Chat_MessagesScalarWhereInput
    data: XOR<Chat_MessagesUpdateManyMutationInput, Chat_MessagesUncheckedUpdateManyWithoutChat_MessagesInput>
  }

  export type Chat_MessagesScalarWhereInput = {
    AND?: Enumerable<Chat_MessagesScalarWhereInput>
    OR?: Enumerable<Chat_MessagesScalarWhereInput>
    NOT?: Enumerable<Chat_MessagesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    Message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
  }

  export type IncidentUpsertWithWhereUniqueWithoutUserInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutUserInput, IncidentUncheckedUpdateWithoutUserInput>
    create: XOR<IncidentCreateWithoutUserInput, IncidentUncheckedCreateWithoutUserInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutUserInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutUserInput, IncidentUncheckedUpdateWithoutUserInput>
  }

  export type IncidentUpdateManyWithWhereWithoutUserInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutIncidentInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: Enumerable<IncidentScalarWhereInput>
    OR?: Enumerable<IncidentScalarWhereInput>
    NOT?: Enumerable<IncidentScalarWhereInput>
    id?: IntFilter | number
    Co_Credit?: StringFilter | string
    Country?: StringFilter | string
    Time?: DateTimeFilter | Date | string
    Type?: StringFilter | string
    Street?: StringFilter | string
    City?: StringFilter | string
    State?: StringFilter | string
    Longitude?: FloatFilter | number
    Latitude?: FloatFilter | number
    Zipcode?: IntFilter | number
    Text?: StringFilter | string
    SMS_Chr_Count?: IntFilter | number
    Internal_Note?: StringFilter | string
    Confirmed_Incident?: BoolFilter | boolean
    Queue?: BoolFilter | boolean
    userId?: IntFilter | number
  }

  export type UserCreateWithoutUser_ProfileInput = {
    username: string
    email: string
    password: string
    role: string
    Residence?: ResidenceCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesCreateNestedManyWithoutUserInput
    Incident?: IncidentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_ProfileInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
    Residence?: ResidenceUncheckedCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesUncheckedCreateNestedManyWithoutUserInput
    Incident?: IncidentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_ProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_ProfileInput, UserUncheckedCreateWithoutUser_ProfileInput>
  }

  export type UserUpsertWithoutUser_ProfileInput = {
    update: XOR<UserUpdateWithoutUser_ProfileInput, UserUncheckedUpdateWithoutUser_ProfileInput>
    create: XOR<UserCreateWithoutUser_ProfileInput, UserUncheckedCreateWithoutUser_ProfileInput>
  }

  export type UserUpdateWithoutUser_ProfileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Residence?: ResidenceUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUpdateManyWithoutUserNestedInput
    Incident?: IncidentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_ProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    Residence?: ResidenceUncheckedUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUncheckedUpdateManyWithoutUserNestedInput
    Incident?: IncidentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutResidenceInput = {
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesCreateNestedManyWithoutUserInput
    Incident?: IncidentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResidenceInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileUncheckedCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesUncheckedCreateNestedManyWithoutUserInput
    Incident?: IncidentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResidenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResidenceInput, UserUncheckedCreateWithoutResidenceInput>
  }

  export type UserUpsertWithoutResidenceInput = {
    update: XOR<UserUpdateWithoutResidenceInput, UserUncheckedUpdateWithoutResidenceInput>
    create: XOR<UserCreateWithoutResidenceInput, UserUncheckedCreateWithoutResidenceInput>
  }

  export type UserUpdateWithoutResidenceInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUpdateManyWithoutUserNestedInput
    Incident?: IncidentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResidenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUncheckedUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUncheckedUpdateManyWithoutUserNestedInput
    Incident?: IncidentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIncidentInput = {
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileCreateNestedManyWithoutUserInput
    Residence?: ResidenceCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIncidentInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileUncheckedCreateNestedManyWithoutUserInput
    Residence?: ResidenceUncheckedCreateNestedManyWithoutUserInput
    Chat_Messages?: Chat_MessagesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIncidentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncidentInput, UserUncheckedCreateWithoutIncidentInput>
  }

  export type UserUpsertWithoutIncidentInput = {
    update: XOR<UserUpdateWithoutIncidentInput, UserUncheckedUpdateWithoutIncidentInput>
    create: XOR<UserCreateWithoutIncidentInput, UserUncheckedCreateWithoutIncidentInput>
  }

  export type UserUpdateWithoutIncidentInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIncidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUncheckedUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUncheckedUpdateManyWithoutUserNestedInput
    Chat_Messages?: Chat_MessagesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChat_MessagesInput = {
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileCreateNestedManyWithoutUserInput
    Residence?: ResidenceCreateNestedManyWithoutUserInput
    Incident?: IncidentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChat_MessagesInput = {
    id?: number
    username: string
    email: string
    password: string
    role: string
    User_Profile?: User_ProfileUncheckedCreateNestedManyWithoutUserInput
    Residence?: ResidenceUncheckedCreateNestedManyWithoutUserInput
    Incident?: IncidentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChat_MessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChat_MessagesInput, UserUncheckedCreateWithoutChat_MessagesInput>
  }

  export type UserUpsertWithoutChat_MessagesInput = {
    update: XOR<UserUpdateWithoutChat_MessagesInput, UserUncheckedUpdateWithoutChat_MessagesInput>
    create: XOR<UserCreateWithoutChat_MessagesInput, UserUncheckedCreateWithoutChat_MessagesInput>
  }

  export type UserUpdateWithoutChat_MessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUpdateManyWithoutUserNestedInput
    Incident?: IncidentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChat_MessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    User_Profile?: User_ProfileUncheckedUpdateManyWithoutUserNestedInput
    Residence?: ResidenceUncheckedUpdateManyWithoutUserNestedInput
    Incident?: IncidentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type User_ProfileCreateManyUserInput = {
    id?: number
    realName: string
    phoneNo: number
    carrier: string
    alertType: string
    pagerEmail: string
    notificationArea: string
    notificationTypes?: User_ProfileCreatenotificationTypesInput | Enumerable<string>
    personalInfo: string
    sendToEmail: boolean
    sendTextNotification: boolean
    sendToPager: boolean
  }

  export type ResidenceCreateManyUserInput = {
    id?: number
    city: string
    address: string
    state: string
    ZipCode: number
    DateOfBirth?: Date | string
    Occupation: string
  }

  export type Chat_MessagesCreateManyUserInput = {
    id?: number
    name: string
    Message: string
    createdAt?: Date | string
  }

  export type IncidentCreateManyUserInput = {
    id?: number
    Co_Credit: string
    Country: string
    Time?: Date | string
    Type: string
    Street: string
    City: string
    State: string
    Longitude: number
    Latitude: number
    Zipcode: number
    Text: string
    SMS_Chr_Count: number
    Internal_Note: string
    Confirmed_Incident: boolean
    Queue?: boolean
  }

  export type User_ProfileUpdateWithoutUserInput = {
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_ProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type User_ProfileUncheckedUpdateManyWithoutUser_ProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    realName?: StringFieldUpdateOperationsInput | string
    phoneNo?: IntFieldUpdateOperationsInput | number
    carrier?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    pagerEmail?: StringFieldUpdateOperationsInput | string
    notificationArea?: StringFieldUpdateOperationsInput | string
    notificationTypes?: User_ProfileUpdatenotificationTypesInput | Enumerable<string>
    personalInfo?: StringFieldUpdateOperationsInput | string
    sendToEmail?: BoolFieldUpdateOperationsInput | boolean
    sendTextNotification?: BoolFieldUpdateOperationsInput | boolean
    sendToPager?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResidenceUpdateWithoutUserInput = {
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
  }

  export type ResidenceUncheckedUpdateManyWithoutResidenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    ZipCode?: IntFieldUpdateOperationsInput | number
    DateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    Occupation?: StringFieldUpdateOperationsInput | string
  }

  export type Chat_MessagesUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Chat_MessagesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Chat_MessagesUncheckedUpdateManyWithoutChat_MessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutUserInput = {
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IncidentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IncidentUncheckedUpdateManyWithoutIncidentInput = {
    id?: IntFieldUpdateOperationsInput | number
    Co_Credit?: StringFieldUpdateOperationsInput | string
    Country?: StringFieldUpdateOperationsInput | string
    Time?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: StringFieldUpdateOperationsInput | string
    Street?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Longitude?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Zipcode?: IntFieldUpdateOperationsInput | number
    Text?: StringFieldUpdateOperationsInput | string
    SMS_Chr_Count?: IntFieldUpdateOperationsInput | number
    Internal_Note?: StringFieldUpdateOperationsInput | string
    Confirmed_Incident?: BoolFieldUpdateOperationsInput | boolean
    Queue?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}